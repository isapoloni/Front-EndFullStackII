import {
  AddToListOption_default,
  CREATE_OPTION,
  DropdownList_default,
  FocusListContext,
  List_default,
  Localization_default,
  PickerCaret_default,
  Popup_default,
  SlideDownTransition_default,
  Spinner,
  WidgetPicker_default,
  Widget_default,
  accessor,
  calendar,
  canShowCreate,
  caretDown,
  caretUp,
  chevronLeft,
  chevronRight,
  chunk,
  dates_default,
  disabled,
  isNullOrInvalid,
  makeArray,
  matches,
  message,
  notify,
  setActiveDescendant,
  times,
  useAccessors,
  useActiveDescendant,
  useAutoFocus,
  useDropdownToggle,
  useFilteredData,
  useFirstFocusedRender,
  useFocusList,
  useFocusManager,
  useHandleSelect,
  useInstanceId,
  useListOption,
  useLocalizer,
  useMessagesWithDefaults,
  useWidgetProps
} from "./chunk-GYCTZDAM.js";
import {
  activeElement
} from "./chunk-BVKCICML.js";
import {
  qsa
} from "./chunk-K2TANFYZ.js";
import {
  canUseDOM_default,
  require_classnames,
  transitionEnd,
  useEventCallback,
  useEventListener,
  useUncontrolled,
  useUncontrolledProp
} from "./chunk-UCCRB3ZK.js";
import "./chunk-QZZHP5KK.js";
import "./chunk-Y67KMEH3.js";
import {
  require_prop_types
} from "./chunk-H34UXRLQ.js";
import {
  require_react_dom
} from "./chunk-GHDA5FLN.js";
import {
  __toESM,
  require_react
} from "./chunk-SA4Q2NBN.js";

// node_modules/react-widgets/esm/Calendar.js
var import_classnames6 = __toESM(require_classnames());
var import_prop_types2 = __toESM(require_prop_types());
var import_react8 = __toESM(require_react());

// node_modules/react-widgets/esm/CalendarHeader.js
var import_react = __toESM(require_react());

// node_modules/react-widgets/esm/CalendarButton.js
var import_classnames2 = __toESM(require_classnames());
var React2 = __toESM(require_react());

// node_modules/react-widgets/esm/Button.js
var import_classnames = __toESM(require_classnames());
var React = __toESM(require_react());
var _excluded = ["className", "disabled", "label", "icon", "busy", "children", "spinner"];
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function Button(_ref) {
  let {
    className,
    disabled: disabled2,
    label,
    icon,
    busy,
    children,
    spinner = Spinner
  } = _ref, props = _objectWithoutPropertiesLoose(_ref, _excluded);
  return React.createElement("button", _extends({
    tabIndex: -1
  }, props, {
    title: label,
    type: "button",
    disabled: disabled2,
    "aria-label": label,
    "aria-disabled": disabled2,
    className: (0, import_classnames.default)(className, "rw-btn")
  }), busy ? spinner : icon, children);
}
var Button_default = Button;

// node_modules/react-widgets/esm/CalendarButton.js
var _excluded2 = ["className"];
function _extends2() {
  _extends2 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends2.apply(this, arguments);
}
function _objectWithoutPropertiesLoose2(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function CalendarButton(_ref) {
  let {
    className
  } = _ref, props = _objectWithoutPropertiesLoose2(_ref, _excluded2);
  return React2.createElement(Button_default, _extends2({}, props, {
    tabIndex: void 0,
    className: (0, import_classnames2.default)(className, "rw-calendar-btn")
  }));
}
var CalendarButton_default = CalendarButton;

// node_modules/react-widgets/esm/CalendarHeader.js
function CalendarHeader({
  localizer,
  label,
  labelId,
  onMoveRight,
  onMoveToday,
  onMoveLeft,
  onViewChange,
  prevDisabled,
  todayDisabled,
  upDisabled,
  nextDisabled,
  navigatePrevIcon = chevronLeft,
  navigateNextIcon = chevronRight
}) {
  return import_react.default.createElement("div", {
    className: "rw-calendar-header"
  }, import_react.default.createElement(CalendarButton_default, {
    id: labelId,
    onClick: onViewChange,
    className: "rw-calendar-btn-view",
    disabled: upDisabled,
    "aria-live": "polite",
    "aria-atomic": "true"
  }, label, " ", caretDown), import_react.default.createElement(CalendarButton_default, {
    className: "rw-calendar-btn-left",
    onClick: onMoveLeft,
    disabled: prevDisabled,
    label: localizer.messages.moveBack(),
    icon: navigatePrevIcon
  }), import_react.default.createElement(CalendarButton_default, {
    className: "rw-calendar-btn-today",
    disabled: todayDisabled,
    onClick: onMoveToday
  }, localizer.messages.moveToday()), import_react.default.createElement(CalendarButton_default, {
    className: "rw-calendar-btn-right",
    onClick: onMoveRight,
    disabled: nextDisabled,
    label: localizer.messages.moveForward(),
    icon: navigateNextIcon
  }));
}
var CalendarHeader_default = CalendarHeader;

// node_modules/react-widgets/esm/Century.js
var import_react3 = __toESM(require_react());

// node_modules/react-widgets/esm/CalendarView.js
var import_classnames3 = __toESM(require_classnames());
var import_react2 = __toESM(require_react());
function _extends3() {
  _extends3 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends3.apply(this, arguments);
}
function clamp(date, min, max) {
  return dates_default.max(dates_default.min(date, max), min);
}
function CalendarView({
  className,
  focusedItem,
  onKeyDown,
  children,
  "aria-labelledby": labelledby
}) {
  const ref = (0, import_react2.useRef)(null);
  const [focusEvents, focused] = useFocusManager(ref);
  (0, import_react2.useEffect)(() => {
    var _node$querySelector;
    const node2 = ref.current;
    if (!node2 || !focused)
      return;
    (_node$querySelector = node2.querySelector(".rw-cell[tabindex]")) == null ? void 0 : _node$querySelector.focus();
  }, [focusedItem, focused, ref]);
  return import_react2.default.createElement("div", _extends3({
    role: "grid",
    ref,
    tabIndex: -1
  }, focusEvents, {
    onKeyDown,
    "aria-labelledby": labelledby,
    className: (0, import_classnames3.default)(className, "rw-nav-view", "rw-calendar-grid")
  }), children);
}
function CalendarViewCell({
  onChange,
  min,
  max,
  date,
  unit,
  disabled: disabled2,
  selected,
  focusedItem,
  viewUnit,
  children,
  label
}) {
  const isEqual = (nextDate) => dates_default.eq(date, nextDate, unit);
  const isEmpty = !dates_default.inRange(date, min, max, unit);
  const isDisabled = disabled2 || isEmpty;
  const isFocused = !disabled2 && !isEmpty && isEqual(focusedItem);
  const isSelected = selected && isEqual(selected);
  const isOffView = date && focusedItem && viewUnit && dates_default[viewUnit](date) !== dates_default[viewUnit](focusedItem);
  const handleChange = () => {
    onChange(clamp(date, min, max));
  };
  return import_react2.default.createElement("div", {
    role: "gridcell",
    title: label,
    "aria-label": label,
    "aria-readonly": disabled2,
    "aria-selected": Boolean(isSelected),
    tabIndex: isFocused ? 0 : void 0,
    onClick: !isDisabled ? handleChange : void 0,
    className: (0, import_classnames3.default)(
      "rw-cell",
      // isNow && 'rw-now',
      isDisabled && "rw-state-disabled",
      isEmpty && "rw-cell-not-allowed",
      isOffView && "rw-cell-off-range",
      isSelected && "rw-state-selected"
    )
  }, import_react2.default.createElement("span", {
    "aria-hidden": true
  }, children));
}
CalendarView.Body = (props) => import_react2.default.createElement("div", _extends3({
  role: "rowgroup",
  className: "rw-calendar-body"
}, props));
CalendarView.Row = (props) => import_react2.default.createElement("div", _extends3({
  role: "row",
  className: "rw-calendar-row"
}, props));
CalendarView.Cell = CalendarViewCell;
var CalendarView_default = CalendarView;

// node_modules/react-widgets/esm/Century.js
var _excluded3 = ["focusedItem", "disabled", "onChange", "value", "localizer", "min", "max"];
function _extends4() {
  _extends4 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends4.apply(this, arguments);
}
function _objectWithoutPropertiesLoose3(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function CenturyView(_ref) {
  let {
    focusedItem,
    disabled: disabled2,
    onChange,
    value,
    localizer,
    min,
    max
  } = _ref, props = _objectWithoutPropertiesLoose3(_ref, _excluded3);
  const chunks = (0, import_react3.useMemo)(() => chunk(getCenturyDecades(focusedItem), 4), [focusedItem]);
  return import_react3.default.createElement(CalendarView_default, _extends4({}, props, {
    focusedItem
  }), import_react3.default.createElement(CalendarView_default.Body, null, chunks.map((row, rowIdx) => import_react3.default.createElement(CalendarView_default.Row, {
    key: rowIdx
  }, row.map((date, colIdx) => {
    let label = localizer.formatDate(dates_default.startOf(date, "decade"), "decade");
    return import_react3.default.createElement(CalendarView_default.Cell, {
      key: colIdx,
      unit: "decade",
      viewUnit: "century",
      label,
      date,
      min,
      max,
      onChange,
      focusedItem,
      selected: value,
      disabled: disabled2
    }, label);
  })))));
}
function getCenturyDecades(_date) {
  let days = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
  let date = dates_default.add(dates_default.startOf(_date, "century"), -20, "year");
  return days.map(() => date = dates_default.add(date, 10, "year"));
}
var Century_default = CenturyView;

// node_modules/react-widgets/esm/Decade.js
var import_react4 = __toESM(require_react());
var _excluded4 = ["focusedItem", "disabled", "onChange", "value", "localizer", "min", "max"];
function _extends5() {
  _extends5 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends5.apply(this, arguments);
}
function _objectWithoutPropertiesLoose4(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function DecadeView(_ref) {
  let {
    focusedItem,
    disabled: disabled2,
    onChange,
    value,
    localizer,
    min,
    max
  } = _ref, props = _objectWithoutPropertiesLoose4(_ref, _excluded4);
  const chunks = (0, import_react4.useMemo)(() => chunk(getDecadeYears(focusedItem), 4), [focusedItem]);
  return import_react4.default.createElement(CalendarView_default, _extends5({}, props, {
    focusedItem
  }), import_react4.default.createElement(CalendarView_default.Body, null, chunks.map((row, rowIdx) => import_react4.default.createElement(CalendarView_default.Row, {
    key: rowIdx
  }, row.map((date, colIdx) => {
    let label = localizer.formatDate(date, "year");
    return import_react4.default.createElement(CalendarView_default.Cell, {
      key: colIdx,
      unit: "year",
      viewUnit: "decade",
      label,
      date,
      min,
      max,
      onChange,
      focusedItem,
      selected: value,
      disabled: disabled2
    }, label);
  })))));
}
function getDecadeYears(_date) {
  let days = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
  let date = dates_default.add(dates_default.startOf(_date, "decade"), -2, "year");
  return days.map(() => date = dates_default.add(date, 1, "year"));
}
var Decade_default = DecadeView;

// node_modules/react-widgets/esm/Month.js
var import_classnames4 = __toESM(require_classnames());
var import_react5 = __toESM(require_react());
var _excluded5 = ["className", "focusedItem", "disabled", "onChange", "value", "min", "max", "localizer", "renderDay"];
function _extends6() {
  _extends6 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends6.apply(this, arguments);
}
function _objectWithoutPropertiesLoose5(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function visibleDays(date, weekStart) {
  let current = dates_default.startOf(dates_default.startOf(date, "month"), "week", weekStart);
  let last2 = dates_default.endOf(dates_default.endOf(date, "month"), "week", weekStart);
  let days = [];
  while (dates_default.lte(current, last2, "day")) {
    days.push(current);
    current = dates_default.add(current, 1, "day");
  }
  return days;
}
function MonthView(_ref) {
  let {
    className,
    focusedItem,
    disabled: disabled2,
    onChange,
    value,
    min,
    max,
    localizer,
    renderDay
  } = _ref, props = _objectWithoutPropertiesLoose5(_ref, _excluded5);
  let month = visibleDays(focusedItem, localizer.firstOfWeek());
  let rows = chunk(month, 7);
  return import_react5.default.createElement(CalendarView_default, _extends6({}, props, {
    focusedItem,
    className: (0, import_classnames4.default)(className, "rw-calendar-month")
  }), import_react5.default.createElement("div", {
    role: "rowgroup",
    className: "rw-calendar-head"
  }, import_react5.default.createElement(CalendarView_default.Row, {
    className: "rw-calendar-row"
  }, rows[0].map((date, idx) => import_react5.default.createElement("div", {
    role: "columnheader",
    className: "rw-head-cell",
    key: idx
  }, localizer.formatDate(date, "weekday"))))), import_react5.default.createElement(CalendarView_default.Body, null, rows.map((row, rowIdx) => import_react5.default.createElement(CalendarView_default.Row, {
    key: rowIdx
  }, row.map((date, colIdx) => {
    let formattedDate = localizer.formatDate(date, "dayOfMonth");
    let label = localizer.formatDate(date, "date");
    return import_react5.default.createElement(CalendarView_default.Cell, {
      key: colIdx,
      label,
      date,
      min,
      max,
      unit: "day",
      viewUnit: "month",
      onChange,
      focusedItem,
      selected: value,
      disabled: disabled2
    }, renderDay ? renderDay({
      date,
      label: formattedDate
    }) : formattedDate);
  })))));
}
var Month_default = MonthView;

// node_modules/react-widgets/esm/SlideTransitionGroup.js
var import_classnames5 = __toESM(require_classnames());
var import_prop_types = __toESM(require_prop_types());
var import_react6 = __toESM(require_react());
var _excluded6 = ["direction", "children", "onTransitionEnd"];
function _extends7() {
  _extends7 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends7.apply(this, arguments);
}
function _objectWithoutPropertiesLoose6(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var DirectionPropType = import_prop_types.default.oneOf(["left", "right", "top", "bottom"]);
var prefix = "rw-calendar-transition";
var active = "rw-calendar-transition-active";
var next = "rw-calendar-transition-next";
var prev = "rw-calendar-transition-prev";
var clone = (el, cls) => el && import_react6.default.cloneElement(el, {
  className: (0, import_classnames5.default)(el.props.className, prefix, cls)
});
var SlideTransitionGroup = class extends import_react6.default.Component {
  constructor(args) {
    super(args);
    this.handleTransitionEnd = (hadFocus) => {
      this.isTransitioning = false;
      let current = this.container.current.lastChild;
      if (this.props.onTransitionEnd)
        this.props.onTransitionEnd(current, hadFocus);
    };
    this.current = this.props.children;
    this.container = import_react6.default.createRef();
    this.state = {
      prevClasses: "",
      currentClasses: ""
    };
  }
  componentDidUpdate() {
    if (!this.flush || this.isTransitioning)
      return;
    this.flush = false;
    this.isTransitioning = true;
    let previous = this.container.current.firstChild;
    const hadFocus = document.activeElement && previous.contains(document.activeElement);
    this.setState({
      prevClasses: "",
      currentClasses: next
    }, () => {
      let current = this.container.current.lastChild;
      current.clientHeight;
      this.setState({
        prevClasses: prev,
        currentClasses: (0, import_classnames5.default)(next, active)
      }, () => {
        transitionEnd(current, () => {
          this.prev = null;
          if (this.current.key !== this.props.children.key) {
            this.current = this.props.children;
          }
          this.setState({
            prevClasses: "",
            currentClasses: ""
          }, () => this.handleTransitionEnd(hadFocus));
        });
      });
    });
  }
  render() {
    let _this$props = this.props, {
      direction,
      children
    } = _this$props, props = _objectWithoutPropertiesLoose6(_this$props, _excluded6);
    if (!this.isTransitioning) {
      if (this.current.key !== children.key) {
        this.prev = this.current;
        this.flush = true;
      }
      this.current = children;
    }
    let {
      prevClasses,
      currentClasses
    } = this.state;
    return import_react6.default.createElement("div", _extends7({}, props, {
      ref: this.container,
      className: (0, import_classnames5.default)(`rw-calendar-transition-group`, direction === "top" && "rw-calendar-transition-top", direction === "right" && "rw-calendar-transition-right", direction === "bottom" && "rw-calendar-transition-bottom", direction === "left" && "rw-calendar-transition-left")
    }), clone(this.prev, prevClasses), clone(this.current, currentClasses));
  }
};
SlideTransitionGroup.defaultProps = {
  direction: "left"
};
SlideTransitionGroup.propTypes = {
  direction: DirectionPropType,
  onTransitionEnd: import_prop_types.default.func
};
var SlideTransitionGroup_default = SlideTransitionGroup;

// node_modules/react-widgets/esm/Year.js
var import_react7 = __toESM(require_react());
var _excluded7 = ["focusedItem", "disabled", "onChange", "value", "min", "localizer", "max"];
function _extends8() {
  _extends8 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends8.apply(this, arguments);
}
function _objectWithoutPropertiesLoose7(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var months = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
function monthsInYear(year) {
  let date = new Date(year, 0, 1);
  return months.map((i) => dates_default.month(date, i));
}
function YearView(_ref) {
  let {
    focusedItem,
    disabled: disabled2,
    onChange,
    value,
    min,
    localizer,
    max
  } = _ref, props = _objectWithoutPropertiesLoose7(_ref, _excluded7);
  let months2 = monthsInYear(dates_default.year(focusedItem));
  return import_react7.default.createElement(CalendarView_default, _extends8({}, props, {
    focusedItem
  }), import_react7.default.createElement(CalendarView_default.Body, null, chunk(months2, 4).map((row, rowIdx) => import_react7.default.createElement(CalendarView_default.Row, {
    key: rowIdx
  }, row.map((date, colIdx) => {
    let label = localizer.formatDate(date, "header");
    return import_react7.default.createElement(CalendarView_default.Cell, {
      key: colIdx,
      label,
      date,
      min,
      max,
      unit: "month",
      viewUnit: "year",
      onChange,
      focusedItem,
      selected: value,
      disabled: disabled2
    }, localizer.formatDate(date, "month"));
  })))));
}
var Year_default = YearView;

// node_modules/react-widgets/esm/Calendar.js
var _excluded8 = ["id", "autoFocus", "bordered", "views", "tabIndex", "disabled", "readOnly", "className", "value", "defaultValue", "onChange", "currentDate", "defaultCurrentDate", "onCurrentDateChange", "min", "max", "view", "defaultView", "onViewChange", "onKeyDown", "onNavigate", "renderDay", "messages", "formats"];
function _extends9() {
  _extends9 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends9.apply(this, arguments);
}
function _objectWithoutPropertiesLoose8(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var last = (a) => a[a.length - 1];
var CELL_CLASSNAME = "rw-cell";
var FOCUSED_CELL_SELECTOR = `.${CELL_CLASSNAME}[tabindex]`;
var MIN = new Date(1900, 0, 1);
var MAX = new Date(2099, 11, 31);
var VIEW_OPTIONS = ["month", "year", "decade", "century"];
var VIEW_UNIT = {
  month: "day",
  year: "month",
  decade: "year",
  century: "decade"
};
var VIEW = {
  month: Month_default,
  year: Year_default,
  decade: Decade_default,
  century: Century_default
};
var ARROWS_TO_DIRECTION = {
  ArrowDown: "DOWN",
  ArrowUp: "UP",
  ArrowRight: "RIGHT",
  ArrowLeft: "LEFT"
};
var OPPOSITE_DIRECTION = {
  LEFT: "RIGHT",
  RIGHT: "LEFT"
};
var MULTIPLIER = {
  year: 1,
  decade: 10,
  century: 100
};
function inRangeValue(_value, min, max) {
  let value = dateOrNull(_value);
  if (value === null)
    return value;
  return dates_default.max(dates_default.min(value, max), min);
}
var propTypes = {
  /**
   * @example ['disabled', ['new Date()']]
   */
  disabled: import_prop_types2.default.bool,
  /**
   * @example ['readOnly', ['new Date()']]
   */
  readOnly: import_prop_types2.default.bool,
  /**
   * @example ['onChangePicker', [ ['new Date()'] ]]
   */
  onChange: import_prop_types2.default.func,
  /**
   * The selected Date.
   *
   * ```tsx live
   * import { Calendar } from 'react-widgets';
   *
   * <Calendar value={new Date()} />
   * ```
   * @example false
   */
  value: import_prop_types2.default.instanceOf(Date),
  /**
   * The minimum date that the Calendar can navigate from.
   *
   * @example ['prop', ['min', 'new Date()']]
   */
  min: import_prop_types2.default.instanceOf(Date),
  /**
   * The maximum date that the Calendar can navigate to.
   *
   * @example ['prop', ['max', 'new Date()']]
   */
  max: import_prop_types2.default.instanceOf(Date),
  /**
   * Default current date at which the calendar opens. If none is provided, opens at today's date or the `value` date (if any).
   */
  currentDate: import_prop_types2.default.instanceOf(Date),
  /**
   * Change event Handler that is called when the currentDate is changed. The handler is called with the currentDate object.
   */
  onCurrentDateChange: import_prop_types2.default.func,
  /** Specify the navigate into the past header icon */
  navigatePrevIcon: import_prop_types2.default.node,
  /** Specify the navigate into the future header icon */
  navigateNextIcon: import_prop_types2.default.node,
  /**
   * Controls the currently displayed calendar view. Use `defaultView` to set a unique starting view.
   *
   * @type {("month"|"year"|"decade"|"century")}
   * @controllable onViewChange
   */
  view(props, ...args) {
    return import_prop_types2.default.oneOf(props.views || VIEW_OPTIONS)(props, ...args);
  },
  /**
   * Defines a list of views the Calendar can traverse through, starting with the
   * first in the list to the last.
   *
   * @type array<"month"|"year"|"decade"|"century">
   */
  views: import_prop_types2.default.arrayOf(import_prop_types2.default.oneOf(VIEW_OPTIONS)),
  /**
   * A callback fired when the `view` changes.
   *
   * @controllable view
   */
  onViewChange: import_prop_types2.default.func,
  /**
   * Callback fired when the Calendar navigates between views, or forward and backwards in time.
   *
   * @type function(date: ?Date, direction: string, view: string)
   */
  onNavigate: import_prop_types2.default.func,
  culture: import_prop_types2.default.string,
  autoFocus: import_prop_types2.default.bool,
  /**
   * Show or hide the Calendar footer.
   *
   * @example ['prop', ['footer', true]]
   */
  footer: import_prop_types2.default.bool,
  /**
   * Provide a custom component to render the days of the month. The Component is provided the following props
   *
   * - `date`: a `Date` object for the day of the month to render
   * - `label`: a formatted `string` of the date to render. To adjust the format of the `label` string use the `dateFormat` prop, listed below.
   */
  renderDay: import_prop_types2.default.func,
  formats: import_prop_types2.default.shape({
    /**
     * A formatter for the header button of the month view.
     *
     * @example ['dateFormat', ['headerFormat', "{ date: 'medium' }"]]
     */
    header: import_prop_types2.default.any,
    /**
     * A formatter for the Calendar footer, formats today's Date as a string.
     *
     * @example ['dateFormat', ['footerFormat', "{ date: 'medium' }", "date => 'Today is: ' + formatter(date)"]]
     */
    footer: import_prop_types2.default.any,
    /**
     * A formatter calendar days of the week, the default formats each day as a Narrow name: "Mo", "Tu", etc.
     *
     * @example ['prop', { day: "day => \n['🎉', 'M', 'T','W','Th', 'F', '🎉'][day.getDay()]" }]
     */
    day: import_prop_types2.default.any,
    /**
     * A formatter for day of the month
     *
     * @example ['prop', { date: "dt => String(dt.getDate())" }]
     */
    date: import_prop_types2.default.any,
    /**
     * A formatter for month name.
     *
     * @example ['dateFormat', ['monthFormat', "{ raw: 'MMMM' }", null, { defaultView: '"year"' }]]
     */
    month: import_prop_types2.default.any,
    /**
     * A formatter for month name.
     *
     * @example ['dateFormat', ['yearFormat', "{ raw: 'yy' }", null, { defaultView: '"decade"' }]]
     */
    year: import_prop_types2.default.any,
    /**
     * A formatter for decade, the default formats the first and last year of the decade like: 2000 - 2009.
     */
    decade: import_prop_types2.default.any,
    /**
     * A formatter for century, the default formats the first and last year of the century like: 1900 - 1999.
     */
    century: import_prop_types2.default.any
  }),
  messages: import_prop_types2.default.shape({
    moveBack: import_prop_types2.default.string,
    moveForward: import_prop_types2.default.string
  }),
  onKeyDown: import_prop_types2.default.func,
  /** @ignore */
  tabIndex: import_prop_types2.default.any
};
var useViewState = (views, view = views[0], currentDate) => {
  const lastView = (0, import_react8.useRef)(view);
  const lastDate = (0, import_react8.useRef)(currentDate);
  let slideDirection;
  if (view !== lastView.current) {
    slideDirection = views.indexOf(lastView.current) > views.indexOf(view) ? "top" : "bottom";
  } else if (lastDate.current !== currentDate) {
    slideDirection = dates_default.gt(currentDate, lastDate.current) ? "left" : "right";
  }
  (0, import_react8.useEffect)(() => {
    lastDate.current = currentDate;
    lastView.current = view;
  });
  return slideDirection;
};
function Calendar(_ref) {
  let {
    id,
    autoFocus,
    bordered = true,
    views = VIEW_OPTIONS,
    tabIndex = 0,
    disabled: disabled2,
    readOnly,
    className,
    value,
    defaultValue,
    onChange,
    currentDate: pCurrentDate,
    defaultCurrentDate,
    onCurrentDateChange,
    min = MIN,
    max = MAX,
    view,
    defaultView = views[0],
    onViewChange,
    onKeyDown,
    onNavigate,
    renderDay,
    messages,
    formats
  } = _ref, elementProps = _objectWithoutPropertiesLoose8(_ref, _excluded8);
  const [currentValue, handleChange] = useUncontrolledProp(value, defaultValue, onChange);
  const [currentDate, handleCurrentDateChange] = useUncontrolledProp(pCurrentDate, defaultCurrentDate || currentValue || /* @__PURE__ */ new Date(), onCurrentDateChange);
  const [currentView, handleViewChange] = useUncontrolledProp(view, defaultView, onViewChange);
  const localizer = useLocalizer(messages, formats);
  const ref = (0, import_react8.useRef)(null);
  const viewId = useInstanceId(id, "_calendar");
  const labelId = useInstanceId(id, "_calendar_label");
  useAutoFocus(!!autoFocus, ref);
  const slideDirection = useViewState(views, currentView, currentDate);
  const [, focused] = useFocusManager(ref, {
    disabled: disabled2
  }, {
    willHandle() {
      if (tabIndex == -1)
        return false;
    }
  });
  const lastValue = (0, import_react8.useRef)(currentValue);
  (0, import_react8.useEffect)(() => {
    const inValue = inRangeValue(currentValue, min, max);
    const last2 = lastValue.current;
    lastValue.current = currentValue;
    if (!dates_default.eq(inValue, dateOrNull(last2), VIEW_UNIT[currentView]))
      maybeSetCurrentDate(inValue);
  });
  const isDisabled = disabled2 || readOnly;
  const handleViewChangeImpl = () => {
    navigate("UP");
  };
  const handleMoveBack = () => {
    navigate("LEFT");
  };
  const handleMoveForward = () => {
    navigate("RIGHT");
  };
  const handleDateChange = (date) => {
    if (views[0] === currentView) {
      maybeSetCurrentDate(date);
      notify(handleChange, [date]);
      focus();
      return;
    }
    navigate("DOWN", date);
  };
  const handleMoveToday = () => {
    let date = /* @__PURE__ */ new Date();
    let firstView = views[0];
    notify(onChange, [date]);
    if (dates_default.inRange(date, min, max, firstView)) {
      focus();
      maybeSetCurrentDate(date);
      notify(handleViewChange, [firstView]);
    }
  };
  const handleKeyDown = (e) => {
    let ctrl = e.ctrlKey || e.metaKey;
    let key2 = e.key;
    let direction = ARROWS_TO_DIRECTION[key2];
    let unit = VIEW_UNIT[currentView];
    if (key2 === "Enter") {
      e.preventDefault();
      return handleDateChange(currentDate);
    }
    if (direction) {
      if (ctrl) {
        e.preventDefault();
        navigate(direction);
      } else {
        const isRTL = getComputedStyle(e.currentTarget).getPropertyValue("direction") === "rtl";
        if (isRTL && direction in OPPOSITE_DIRECTION)
          direction = OPPOSITE_DIRECTION[direction];
        let nextDate2 = Calendar.move(currentDate, min, max, currentView, direction);
        if (!dates_default.eq(currentDate, nextDate2, unit)) {
          e.preventDefault();
          if (dates_default.gt(nextDate2, currentDate, currentView))
            navigate("RIGHT", nextDate2);
          else if (dates_default.lt(nextDate2, currentDate, currentView))
            navigate("LEFT", nextDate2);
          else
            maybeSetCurrentDate(nextDate2);
        }
      }
    }
    notify(onKeyDown, [e]);
  };
  function navigate(direction, date) {
    let nextView = currentView;
    let slideDir = direction === "LEFT" || direction === "UP" ? "right" : "left";
    if (direction === "UP")
      nextView = views[views.indexOf(currentView) + 1] || nextView;
    if (direction === "DOWN")
      nextView = views[views.indexOf(currentView) - 1] || nextView;
    if (!date)
      date = ["LEFT", "RIGHT"].indexOf(direction) !== -1 ? nextDate(direction) : currentDate;
    if (dates_default.inRange(date, min, max, nextView)) {
      notify(onNavigate, [date, slideDir, nextView]);
      maybeSetCurrentDate(date);
      notify(handleViewChange, [nextView]);
    }
  }
  const focus = () => {
    var _ref$current;
    const node2 = (_ref$current = ref.current) == null ? void 0 : _ref$current.querySelector(FOCUSED_CELL_SELECTOR);
    node2 == null ? void 0 : node2.focus();
  };
  const moveFocus = (node2, hadFocus) => {
    let current = document.activeElement;
    if (hadFocus && (!current || !node2.contains(current))) {
      node2.focus();
    }
  };
  function maybeSetCurrentDate(date) {
    let inRangeDate = inRangeValue(date ? new Date(date) : currentDate, min, max);
    if (date === currentDate || dates_default.eq(inRangeDate, dateOrNull(currentDate), VIEW_UNIT[currentView]))
      return;
    notify(handleCurrentDateChange, [inRangeDate]);
  }
  function nextDate(direction) {
    let method = direction === "LEFT" ? "subtract" : "add";
    let unit = currentView === "month" ? currentView : "year";
    let multi = MULTIPLIER[currentView] || 1;
    return dates_default[method](currentDate, 1 * multi, unit);
  }
  function getHeaderLabel() {
    switch (currentView) {
      case "month":
        return localizer.formatDate(currentDate, "header");
      case "year":
        return localizer.formatDate(currentDate, "year");
      case "decade":
        return localizer.formatDate(dates_default.startOf(currentDate, "decade"), "decade");
      case "century":
        return localizer.formatDate(dates_default.startOf(currentDate, "century"), "century");
    }
  }
  let View = VIEW[currentView];
  let todayNotInRange = !dates_default.inRange(/* @__PURE__ */ new Date(), min, max, currentView);
  let key = currentView + "_" + dates_default[currentView](currentDate);
  const prevDisabled = isDisabled || !dates_default.inRange(nextDate("LEFT"), min, max, currentView);
  const nextDisabled = isDisabled || !dates_default.inRange(nextDate("RIGHT"), min, max, currentView);
  return import_react8.default.createElement(Widget_default, _extends9({}, elementProps, {
    role: "group",
    ref,
    focused,
    disabled: disabled2,
    readOnly,
    tabIndex,
    className: (0, import_classnames6.default)(className, "rw-calendar", bordered && "rw-calendar-contained")
  }), import_react8.default.createElement(CalendarHeader_default, {
    label: getHeaderLabel(),
    labelId,
    localizer,
    upDisabled: isDisabled || currentView === last(views),
    prevDisabled,
    todayDisabled: isDisabled || todayNotInRange,
    nextDisabled,
    onViewChange: handleViewChangeImpl,
    onMoveLeft: handleMoveBack,
    onMoveRight: handleMoveForward,
    onMoveToday: handleMoveToday
  }), import_react8.default.createElement(Calendar.Transition, {
    direction: slideDirection,
    onTransitionEnd: moveFocus
  }, import_react8.default.createElement(View, {
    key,
    min,
    max,
    id: viewId,
    value: currentValue,
    localizer,
    disabled: isDisabled,
    focusedItem: currentDate,
    onChange: handleDateChange,
    onKeyDown: handleKeyDown,
    "aria-labelledby": labelId,
    renderDay
  })));
}
function dateOrNull(dt) {
  if (dt && !isNaN(dt.getTime()))
    return dt;
  return null;
}
Calendar.displayName = "Calendar";
Calendar.propTypes = propTypes;
Calendar.Transition = SlideTransitionGroup_default;
Calendar.move = (date, min, max, view, direction) => {
  let isMonth = view === "month";
  let isUpOrDown = direction === "UP" || direction === "DOWN";
  let rangeUnit = view && VIEW_UNIT[view];
  let addUnit = isMonth && isUpOrDown ? "week" : VIEW_UNIT[view];
  let amount = isMonth || !isUpOrDown ? 1 : 4;
  let newDate;
  if (direction === "UP" || direction === "LEFT")
    amount *= -1;
  newDate = dates_default.add(date, amount, addUnit);
  return dates_default.inRange(newDate, min, max, rangeUnit) ? newDate : date;
};
var Calendar_default = Calendar;

// node_modules/react-widgets/esm/Combobox.js
var import_classnames9 = __toESM(require_classnames());
var PropTypes4 = __toESM(require_prop_types());
var React13 = __toESM(require_react());
var import_react11 = __toESM(require_react());

// node_modules/react-widgets/esm/Input.js
var import_classnames7 = __toESM(require_classnames());
var import_prop_types3 = __toESM(require_prop_types());
var import_react9 = __toESM(require_react());
var _excluded9 = ["className", "disabled", "readOnly", "value", "tabIndex", "type", "component"];
function _extends10() {
  _extends10 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends10.apply(this, arguments);
}
function _objectWithoutPropertiesLoose9(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var Input = import_react9.default.forwardRef((_ref, ref) => {
  let {
    className,
    disabled: disabled2,
    readOnly,
    value,
    tabIndex,
    type = "text",
    component: Component = "input"
  } = _ref, props = _objectWithoutPropertiesLoose9(_ref, _excluded9);
  return import_react9.default.createElement(Component, _extends10({}, props, {
    ref,
    type,
    tabIndex: tabIndex || 0,
    autoComplete: "off",
    disabled: disabled2,
    readOnly,
    "aria-disabled": disabled2,
    "aria-readonly": readOnly,
    value: value == null ? "" : value,
    className: (0, import_classnames7.default)(className, "rw-input")
  }));
});
Input.displayName = "Input";
Input.propTypes = {
  disabled: import_prop_types3.default.bool,
  readOnly: import_prop_types3.default.bool,
  value: import_prop_types3.default.string,
  type: import_prop_types3.default.string,
  tabIndex: import_prop_types3.default.number,
  component: import_prop_types3.default.any
};
var Input_default = Input;

// node_modules/react-widgets/esm/InputAddon.js
var import_classnames8 = __toESM(require_classnames());
var import_react10 = __toESM(require_react());
var _excluded10 = ["className"];
function _extends11() {
  _extends11 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends11.apply(this, arguments);
}
function _objectWithoutPropertiesLoose10(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function InputAddon(_ref) {
  let {
    className
  } = _ref, props = _objectWithoutPropertiesLoose10(_ref, _excluded10);
  return import_react10.default.createElement(Button_default, _extends11({}, props, {
    className: (0, import_classnames8.default)(className, "rw-input-addon rw-picker-btn")
  }));
}
var InputAddon_default = InputAddon;

// node_modules/react-widgets/esm/Combobox.js
var _excluded11 = ["id", "className", "containerClassName", "placeholder", "autoFocus", "textField", "dataKey", "autoSelectMatches", "focusFirstItem", "value", "defaultValue", "onChange", "open", "defaultOpen", "onToggle", "filter", "busy", "disabled", "readOnly", "selectIcon", "hideCaret", "hideEmptyPopup", "busySpinner", "dropUp", "tabIndex", "popupTransition", "name", "onSelect", "onKeyDown", "onBlur", "onFocus", "inputProps", "listProps", "popupProps", "groupBy", "renderListItem", "renderListGroup", "optionComponent", "listComponent", "popupComponent", "data", "messages"];
function _extends12() {
  _extends12 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends12.apply(this, arguments);
}
function _objectWithoutPropertiesLoose11(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function indexOf(data, searchTerm, text) {
  if (!searchTerm.trim())
    return -1;
  for (let idx = 0; idx < data.length; idx++)
    if (text(data[idx]).toLowerCase() === searchTerm)
      return idx;
  return -1;
}
var propTypes2 = {
  value: PropTypes4.any,
  onChange: PropTypes4.func,
  open: PropTypes4.bool,
  onToggle: PropTypes4.func,
  renderListItem: PropTypes4.func,
  listComponent: PropTypes4.elementType,
  renderListGroup: PropTypes4.func,
  groupBy: accessor,
  data: PropTypes4.array,
  dataKey: accessor,
  textField: accessor,
  name: PropTypes4.string,
  /** Do not show the auto complete list when it returns no results. */
  hideEmptyPopup: PropTypes4.bool,
  /** Hide the combobox dropdown indicator. */
  hideCaret: PropTypes4.bool,
  /**
   *
   * @type {(dataItem: ?any, metadata: { originalEvent: SyntheticEvent }) => void}
   */
  onSelect: PropTypes4.func,
  autoFocus: PropTypes4.bool,
  disabled: disabled.acceptsArray,
  readOnly: disabled,
  busy: PropTypes4.bool,
  /** Specify the element used to render the select (down arrow) icon. */
  selectIcon: PropTypes4.node,
  /** Specify the element used to render the busy indicator */
  busySpinner: PropTypes4.node,
  dropUp: PropTypes4.bool,
  popupTransition: PropTypes4.elementType,
  placeholder: PropTypes4.string,
  /** Adds a css class to the input container element. */
  containerClassName: PropTypes4.string,
  inputProps: PropTypes4.object,
  listProps: PropTypes4.object,
  messages: PropTypes4.shape({
    openCombobox: message,
    emptyList: message,
    emptyFilter: message
  })
};
var ComboboxImpl = React13.forwardRef(function Combobox(_ref, outerRef) {
  let {
    id,
    className,
    containerClassName,
    placeholder,
    autoFocus,
    textField,
    dataKey,
    autoSelectMatches,
    focusFirstItem = false,
    value,
    defaultValue = "",
    onChange,
    open,
    defaultOpen = false,
    onToggle,
    filter = true,
    busy,
    disabled: disabled2,
    readOnly,
    selectIcon = caretDown,
    hideCaret,
    hideEmptyPopup,
    busySpinner,
    dropUp,
    tabIndex,
    popupTransition,
    name,
    onSelect,
    onKeyDown,
    onBlur,
    onFocus,
    inputProps,
    listProps,
    popupProps,
    groupBy,
    renderListItem,
    renderListGroup,
    optionComponent,
    listComponent: ListComponent = List_default,
    popupComponent: Popup = Popup_default,
    data: rawData = [],
    messages: userMessages
  } = _ref, elementProps = _objectWithoutPropertiesLoose11(_ref, _excluded11);
  let [currentValue, handleChange] = useUncontrolledProp(value, defaultValue, onChange);
  const [currentOpen, handleOpen] = useUncontrolledProp(open, defaultOpen, onToggle);
  const ref = (0, import_react11.useRef)(null);
  const inputRef = (0, import_react11.useRef)(null);
  const listRef = (0, import_react11.useRef)(null);
  const [suggestion, setSuggestion] = (0, import_react11.useState)(null);
  const shouldFilter = (0, import_react11.useRef)(false);
  const inputId = useInstanceId(id, "_input");
  const listId = useInstanceId(id, "_listbox");
  const activeId = useInstanceId(id, "_listbox_active_option");
  const accessors = useAccessors(textField, dataKey);
  const messages = useMessagesWithDefaults(userMessages);
  const toggle = useDropdownToggle(currentOpen, handleOpen);
  const isDisabled = disabled2 === true;
  const isReadOnly = !!readOnly;
  const data = useFilteredData(rawData, filter, shouldFilter.current ? accessors.text(currentValue) : void 0, accessors.text);
  const selectedItem = (0, import_react11.useMemo)(() => data[accessors.indexOf(data, currentValue)], [data, currentValue, accessors]);
  const list = useFocusList({
    activeId,
    scope: ref,
    focusFirstItem,
    anchorItem: currentOpen ? selectedItem : void 0
  });
  const [focusEvents, focused] = useFocusManager(ref, {
    disabled: isDisabled,
    onBlur,
    onFocus
  }, {
    didHandle(focused2) {
      if (!focused2) {
        shouldFilter.current = false;
        toggle.close();
        setSuggestion(null);
        list.focus(void 0);
      } else {
        focus({
          preventScroll: true
        });
      }
    }
  });
  useActiveDescendant(ref, activeId, currentOpen, [list.getFocused()]);
  const handleClick = (e) => {
    if (readOnly || isDisabled)
      return;
    e.preventDefault();
    focus();
    toggle();
  };
  const handleSelect = (data2, originalEvent) => {
    toggle.close();
    shouldFilter.current = false;
    setSuggestion(null);
    notify(onSelect, [data2, {
      originalEvent
    }]);
    change(data2, originalEvent, true);
    focus({
      preventScroll: true
    });
  };
  const handleInputKeyDown = ({
    key
  }) => {
    if (key === "Backspace" || key === "Delete") {
      list.focus(null);
    }
  };
  const handleInputChange = (event) => {
    let idx = autoSelectMatches ? indexOf(rawData, event.target.value.toLowerCase(), accessors.text) : -1;
    shouldFilter.current = true;
    setSuggestion(null);
    const nextValue = idx === -1 ? event.target.value : rawData[idx];
    change(nextValue, event);
    if (!nextValue)
      toggle.close();
    else
      toggle.open();
  };
  const handleKeyDown = (e) => {
    if (readOnly)
      return;
    let {
      key,
      altKey,
      shiftKey
    } = e;
    notify(onKeyDown, [e]);
    if (e.defaultPrevented)
      return;
    const select = (item) => item != null && handleSelect(item, e);
    const setFocused = (el) => {
      if (!el)
        return;
      setSuggestion(list.toDataItem(el));
      list.focus(el);
    };
    if (key === "End" && currentOpen && !shiftKey) {
      e.preventDefault();
      setFocused(list.last());
    } else if (key === "Home" && currentOpen && !shiftKey) {
      e.preventDefault();
      setFocused(list.first());
    } else if (key === "Escape" && currentOpen) {
      e.preventDefault();
      setSuggestion(null);
      toggle.close();
    } else if (key === "Enter" && currentOpen) {
      e.preventDefault();
      select(list.getFocused());
    } else if (key === "ArrowDown") {
      e.preventDefault();
      if (currentOpen) {
        setFocused(list.next());
      } else {
        return toggle.open();
      }
    } else if (key === "ArrowUp") {
      e.preventDefault();
      if (altKey)
        return toggle.close();
      if (currentOpen) {
        setFocused(list.prev());
      }
    }
  };
  function focus(opts) {
    if (inputRef.current)
      inputRef.current.focus(opts);
  }
  function change(nextValue, originalEvent, selected = false) {
    handleChange(nextValue, {
      lastValue: currentValue,
      originalEvent,
      source: selected ? "listbox" : "input"
    });
  }
  (0, import_react11.useImperativeHandle)(outerRef, () => ({
    focus
  }));
  let shouldRenderPopup = useFirstFocusedRender(focused, currentOpen);
  let valueItem = accessors.findOrSelf(data, currentValue);
  let inputValue = accessors.text(suggestion || valueItem);
  let completeType = filter ? "list" : "none";
  let popupOpen = currentOpen && (!hideEmptyPopup || !!data.length);
  let inputReadOnly = (
    // @ts-ignore
    (inputProps == null ? void 0 : inputProps.readOnly) != null ? inputProps == null ? void 0 : inputProps.readOnly : readOnly
  );
  let inputAddon = false;
  if (!hideCaret) {
    inputAddon = React13.createElement(InputAddon_default, {
      busy,
      icon: selectIcon,
      spinner: busySpinner,
      onClick: handleClick,
      disabled: !!isDisabled || isReadOnly,
      label: messages.openCombobox()
    });
  } else if (busy) {
    inputAddon = React13.createElement("span", {
      "aria-hidden": "true",
      className: "rw-btn rw-picker-caret"
    }, busySpinner || Spinner);
  }
  return React13.createElement(Widget_default, _extends12({}, elementProps, {
    ref,
    open: currentOpen,
    dropUp,
    focused,
    disabled: isDisabled,
    readOnly: isReadOnly
  }, focusEvents, {
    onKeyDown: handleKeyDown,
    className: (0, import_classnames9.default)(className, "rw-combobox")
  }), React13.createElement(WidgetPicker_default, {
    className: (0, import_classnames9.default)(containerClassName, hideCaret && "rw-widget-input", hideCaret && !busy && "rw-hide-caret")
  }, React13.createElement(Input_default, _extends12({}, inputProps, {
    role: "combobox",
    name,
    id: inputId,
    className: (0, import_classnames9.default)(
      // @ts-ignore
      inputProps && inputProps.className,
      "rw-combobox-input",
      !hideCaret && "rw-widget-input"
    ),
    autoFocus,
    tabIndex,
    disabled: isDisabled,
    readOnly: inputReadOnly,
    "aria-busy": !!busy,
    "aria-owns": listId,
    "aria-autocomplete": completeType,
    "aria-expanded": currentOpen,
    "aria-haspopup": true,
    placeholder,
    value: inputValue,
    onChange: handleInputChange,
    onKeyDown: handleInputKeyDown,
    ref: inputRef
  })), inputAddon), React13.createElement(FocusListContext.Provider, {
    value: list.context
  }, shouldRenderPopup && React13.createElement(Popup, _extends12({}, popupProps, {
    dropUp,
    open: popupOpen,
    transition: popupTransition,
    onEntering: () => listRef.current.scrollIntoView()
  }), React13.createElement(ListComponent, _extends12({}, listProps, {
    id: listId,
    tabIndex: -1,
    data,
    groupBy,
    disabled: disabled2,
    accessors,
    renderItem: renderListItem,
    renderGroup: renderListGroup,
    optionComponent,
    value: selectedItem,
    searchTerm: valueItem && accessors.text(valueItem) || "",
    "aria-hidden": !popupOpen,
    "aria-labelledby": inputId,
    "aria-live": popupOpen ? "polite" : void 0,
    onChange: (d, meta) => handleSelect(d, meta.originalEvent),
    ref: listRef,
    messages: {
      emptyList: rawData.length ? messages.emptyFilter : messages.emptyList
    }
  })))));
});
ComboboxImpl.displayName = "Combobox";
ComboboxImpl.propTypes = propTypes2;
var Combobox_default = ComboboxImpl;

// node_modules/react-widgets/esm/DatePicker.js
var import_classnames11 = __toESM(require_classnames());
var import_prop_types5 = __toESM(require_prop_types());
var import_react16 = __toESM(require_react());

// node_modules/react-widgets/esm/DatePickerInput.js
var import_react12 = __toESM(require_react());
var _excluded12 = ["value", "formatter", "editing", "editFormat", "displayFormat", "localizer", "parse", "onChange", "onBlur", "disabled", "readOnly"];
function _extends13() {
  _extends13 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends13.apply(this, arguments);
}
function _objectWithoutPropertiesLoose12(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var DatePickerInput = import_react12.default.forwardRef((_ref, ref) => {
  let {
    value,
    formatter,
    editing,
    editFormat,
    displayFormat,
    localizer,
    parse,
    onChange,
    onBlur,
    disabled: disabled2,
    readOnly
  } = _ref, props = _objectWithoutPropertiesLoose12(_ref, _excluded12);
  const needsFlush = (0, import_react12.useRef)(false);
  const nextTextValue = (0, import_react12.useMemo)(() => value instanceof Date && isValid(value) ? localizer.formatDate(value, formatter, editing ? editFormat : displayFormat) : "", [value, formatter, localizer, displayFormat, editing, editFormat]);
  const [prevValue, setPrevValue] = (0, import_react12.useState)(nextTextValue);
  const [textValue, setTextValue] = (0, import_react12.useState)(nextTextValue);
  if (prevValue !== nextTextValue) {
    setPrevValue(nextTextValue);
    setTextValue(nextTextValue);
  }
  const handleBlur = (event) => {
    if (onBlur)
      onBlur(event);
    if (needsFlush.current) {
      let date = parse(event.target.value);
      const dateIsInvalid = event.target.value != "" && isNullOrInvalid(date);
      if (dateIsInvalid) {
        setTextValue("");
      }
      needsFlush.current = false;
      setPrevValue(null);
      onChange(date, event.target.value);
    }
  };
  const handleChange = ({
    target
  }) => {
    needsFlush.current = true;
    setTextValue(target.value);
  };
  return import_react12.default.createElement(Input_default, _extends13({}, props, {
    type: "text",
    ref,
    className: "rw-widget-input",
    value: textValue,
    disabled: disabled2,
    readOnly,
    onChange: handleChange,
    onBlur: handleBlur
  }));
});
DatePickerInput.displayName = "DatePickerInput";
var DatePickerInput_default = DatePickerInput;
function isValid(d) {
  return !isNaN(d.getTime());
}

// node_modules/react-widgets/esm/TimeInput.js
var import_classnames10 = __toESM(require_classnames());
var import_prop_types4 = __toESM(require_prop_types());
var import_react14 = __toESM(require_react());

// node_modules/react-widgets/esm/DateTimePartInput.js
var import_react13 = __toESM(require_react());
var _excluded13 = ["value", "valueText", "pad", "placeholder", "min", "max", "emptyChar"];
function _extends14() {
  _extends14 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends14.apply(this, arguments);
}
function _objectWithoutPropertiesLoose13(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var padStart = (value, len, padding) => {
  let str = String(value != null ? value : "");
  while (str.length < len)
    str = padding + str;
  return str;
};
var DateTimePartInput = import_react13.default.forwardRef((_ref, ref) => {
  let {
    value,
    valueText = String(value != null ? value : ""),
    pad,
    placeholder,
    min,
    max,
    emptyChar
  } = _ref, props = _objectWithoutPropertiesLoose13(_ref, _excluded13);
  return import_react13.default.createElement("input", _extends14({}, props, {
    ref,
    "data-focusable": true,
    autoComplete: "off",
    role: "spinbutton",
    "aria-valuenow": value != null ? value : void 0,
    "aria-valuemin": min,
    "aria-valuemax": max,
    "aria-valuetext": valueText,
    "aria-disabled": props.disabled || props.readOnly,
    "arai-placeholder": placeholder,
    placeholder,
    className: "rw-time-part-input",
    value: placeholder && !value ? "" : padStart(value, pad || 0, value == null ? emptyChar : "0")
  }));
});
var DateTimePartInput_default = DateTimePartInput;

// node_modules/react-widgets/esm/TimeInput.js
var _excluded14 = ["value", "use12HourClock", "padValues", "emptyCharacter", "precision", "noClearButton", "hoursAddon", "minutesAddon", "secondsAddon", "millisecondsAddon", "className", "disabled", "readOnly", "datePart", "onChange", "onBlur", "onFocus"];
function _extends15() {
  _extends15 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends15.apply(this, arguments);
}
function _objectWithoutPropertiesLoose14(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var selectTextRange = (el) => {
  if (el instanceof HTMLInputElement)
    return el.select();
  const range = document.createRange();
  range.selectNodeContents(el);
  const selection = window.getSelection();
  if (selection) {
    selection.removeAllRanges();
    selection.addRange(range);
  }
};
var isEmptyValue = (p, precision) => p.hours == null && p.minutes == null && (precision != "seconds" && precision !== "milliseconds" || p.seconds == null) && (precision !== "milliseconds" || p.milliseconds == null);
var isPartialValue = (p, precision) => p.hours == null || p.minutes == null || (precision === "seconds" || precision === "milliseconds") && p.seconds == null || precision === "milliseconds" && p.milliseconds == null;
var getValueParts = (value, use12HourClock) => {
  let hours, minutes, seconds, milliseconds;
  let meridiem = "AM";
  if (value) {
    hours = value.getHours();
    if (use12HourClock) {
      meridiem = hours < 12 ? "AM" : "PM";
      hours = hours % 12 || 12;
    }
    minutes = value.getMinutes();
    seconds = value.getSeconds();
    milliseconds = value.getMilliseconds();
  }
  return {
    hours,
    minutes,
    seconds,
    milliseconds,
    meridiem
  };
};
var TEST_VALID = {
  hours: /^([1]?[0-9]|2[0-3])$/,
  hours12: /^(1[0-2]|0?[1-9])$/,
  minutes: /^([0-5]?\d)$/,
  seconds: /^([0-5]?\d)$/,
  milliseconds: /^(\d{1,3})$/
};
var TEST_COMPLETE = {
  hours: /^([3-9]|\d{2})$/,
  hours12: /^(\d{2}|[2-9])$/,
  minutes: /^(d{2}|[6-9])$/,
  seconds: /^(d{2}|[6-9])$/,
  milliseconds: /^(\d{3})$/
};
function testPart(value, part, use12HourClock, tests) {
  const key = part === "hours" && use12HourClock ? "hours12" : part;
  return tests[key].test(value);
}
var isValid2 = (value, part, use12HourClock) => testPart(value, part, use12HourClock, TEST_VALID);
var isComplete = (value, part, use12HourClock) => testPart(value, part, use12HourClock, TEST_COMPLETE);
var propTypes3 = {
  /**
   * @example ['valuePicker', [ ['new Date()'] ]]
   */
  value: import_prop_types4.default.instanceOf(Date),
  /**
   * @example ['onChangePicker', [ ['new Date()'] ]]
   */
  onChange: import_prop_types4.default.func,
  /**
   * The default date used to construct a new time when the `value` is empty
   *
   * @default new Date()
   **/
  datePart: import_prop_types4.default.instanceOf(Date),
  /**
   * Use a 12 hour clock (with AM/PM) instead of 24 hour one.
   * The configured localizer may provide a default value .
   **/
  use12HourClock: import_prop_types4.default.bool,
  /** Time part values will be padded by `0` */
  padValues: import_prop_types4.default.bool,
  /** The string character used to pad empty, or cleared values */
  emptyCharacter: import_prop_types4.default.string,
  /** Hide the input clear button */
  noClearButton: import_prop_types4.default.bool,
  /**
   * @example ['disabled', ['new Date()']]
   */
  disabled: import_prop_types4.default.bool,
  /**
   * @example ['readOnly', ['new Date()']]
   */
  readOnly: import_prop_types4.default.bool,
  /** Controls how precise of a time can be input **/
  precision: import_prop_types4.default.oneOf(["minutes", "seconds", "milliseconds"]).isRequired,
  /**
   * The seperator between hours and minutes
   * @default ':'
   */
  hoursAddon: import_prop_types4.default.node,
  /**
   * The seperator between hours and minutes
   * @default ':'
   */
  minutesAddon: import_prop_types4.default.node,
  /**
   * The seperator between hours and minutes
   * @default ':'
   */
  secondsAddon: import_prop_types4.default.node,
  /**
   * The seperator between hours and minutes
   * @default '.'
   */
  millisecondsAddon: import_prop_types4.default.node
};
var defaultProps = {
  hoursAddon: ":",
  padValues: true,
  precision: "minutes",
  emptyCharacter: "-"
};
function useTimePartState(value, use12HourClock) {
  const [state, setState] = (0, import_react14.useState)(() => ({
    value,
    use12HourClock,
    timeParts: getValueParts(value, use12HourClock)
  }));
  const setTimeParts = (0, import_react14.useCallback)((timeParts) => setState((s) => Object.assign({}, s, {
    timeParts
  })), [setState]);
  if (state.value !== value || state.use12HourClock !== use12HourClock) {
    setState({
      value,
      use12HourClock,
      timeParts: getValueParts(value, use12HourClock)
    });
  }
  return [state.timeParts, setTimeParts];
}
function TimeInput(uncontrolledProps) {
  const _useUncontrolled = useUncontrolled(uncontrolledProps, {
    value: "onChange"
  }), {
    value,
    use12HourClock,
    padValues: pad,
    emptyCharacter,
    precision,
    noClearButton,
    hoursAddon,
    minutesAddon,
    secondsAddon,
    millisecondsAddon,
    className,
    disabled: disabled2,
    readOnly,
    datePart,
    onChange,
    onBlur,
    onFocus
  } = _useUncontrolled, props = _objectWithoutPropertiesLoose14(_useUncontrolled, _excluded14);
  let minsAddon = minutesAddon !== void 0 ? minutesAddon : precision === "seconds" || precision === "milliseconds" ? ":" : "";
  let secsAddon = secondsAddon !== void 0 ? secondsAddon : precision === "milliseconds" ? ":" : "";
  const ref = (0, import_react14.useRef)(null);
  const hourRef = (0, import_react14.useRef)(null);
  const [focusEvents, focused] = useFocusManager(ref, {
    disabled: disabled2,
    onBlur,
    onFocus
  }, {
    didHandle: (focused2, e) => {
      var _hourRef$current;
      if (!focused2)
        return;
      if (!e.target.dataset.focusable)
        (_hourRef$current = hourRef.current) == null ? void 0 : _hourRef$current.focus();
      else
        select(e.target);
    }
  });
  const [timeParts, setTimeParts] = useTimePartState(value != null ? value : null, use12HourClock != null ? use12HourClock : false);
  function getDatePart() {
    return dates_default.startOf(datePart || /* @__PURE__ */ new Date(), "day");
  }
  const getMin = (part) => part === "hours" ? 1 : 0;
  const getMax = (part) => {
    if (part === "hours")
      return use12HourClock ? 12 : 23;
    if (part === "milliseconds")
      return 999;
    return 59;
  };
  function select(target = document.activeElement) {
    window.Promise.resolve().then(() => {
      if (focused)
        selectTextRange(target);
    });
  }
  const handleClear = () => {
    var _hourRef$current2;
    (_hourRef$current2 = hourRef.current) == null ? void 0 : _hourRef$current2.focus();
    if (value)
      onChange(null);
    else
      setTimeParts(getValueParts(null));
  };
  const handleChange = (part, event) => {
    const currentValue = timeParts[part];
    const {
      target
    } = event;
    const rawValue = target.value;
    let strValue = `${currentValue || ""}${rawValue}`;
    let numValue = +strValue;
    if (isNaN(numValue) || strValue && !isValid2(strValue, part, use12HourClock != null ? use12HourClock : false)) {
      if (isValid2(rawValue, part, use12HourClock != null ? use12HourClock : false) && !isNaN(+rawValue)) {
        strValue = rawValue;
        numValue = +rawValue;
      } else {
        return event.preventDefault();
      }
    }
    const nextValue = target.value ? numValue : null;
    notifyChange({
      [part]: nextValue
    });
    if (nextValue != null && isComplete(strValue, part, use12HourClock != null ? use12HourClock : false)) {
      focusNext(event.currentTarget, 1);
    } else {
      select(target);
    }
  };
  const handleSelect = ({
    target
  }) => {
    select(target);
  };
  const handleKeyDown = (part, event) => {
    const {
      key
    } = event;
    const input = event.currentTarget;
    const {
      selectionStart: start,
      selectionEnd: end
    } = input;
    const isRTL = getComputedStyle(input).getPropertyValue("direction") === "rtl";
    const isMeridiem = part === "meridiem";
    const isNext = key === (isRTL ? "ArrowLeft" : "ArrowRight");
    const isPrev = key === (isRTL ? "ArrowRight" : "ArrowLeft");
    if (key === "ArrowUp") {
      event.preventDefault();
      increment(part, 1);
    }
    if (key === "ArrowDown") {
      event.preventDefault();
      increment(part, -1);
    }
    if (isPrev && (isMeridiem || start - 1 < 0)) {
      event.preventDefault();
      focusNext(input, -1);
    }
    if (isNext && (isMeridiem || input.value.length <= end + 1)) {
      event.preventDefault();
      focusNext(input, 1);
    }
    if (readOnly && key !== "Tab") {
      event.preventDefault();
    }
    if (isMeridiem) {
      if (key === "a" || key === "A")
        notifyChange({
          meridiem: "AM"
        });
      if (key === "p" || key === "P")
        notifyChange({
          meridiem: "PM"
        });
    }
  };
  const increment = (part, inc) => {
    let nextPart = timeParts[part];
    if (part === "meridiem") {
      nextPart = nextPart === "AM" ? "PM" : "AM";
    } else {
      nextPart = (nextPart || 0) + inc;
      if (!isValid2(String(nextPart), part, use12HourClock != null ? use12HourClock : false))
        return;
    }
    notifyChange({
      [part]: nextPart
    });
    select();
  };
  function notifyChange(updates) {
    const nextTimeParts = Object.assign({}, timeParts, updates);
    if (value && isEmptyValue(nextTimeParts, precision)) {
      return onChange(null);
    }
    if (isPartialValue(nextTimeParts, precision))
      return setTimeParts(nextTimeParts);
    let {
      hours: hours2,
      minutes: minutes2,
      seconds: seconds2,
      milliseconds: milliseconds2,
      meridiem: meridiem2
    } = nextTimeParts;
    let nextDate = new Date(value || getDatePart());
    if (use12HourClock) {
      if (hours2 === 12)
        hours2 = 0;
      hours2 += meridiem2 === "PM" ? 12 : 0;
    }
    nextDate.setHours(hours2);
    nextDate.setMinutes(minutes2);
    if (seconds2 != null)
      nextDate.setSeconds(seconds2);
    if (milliseconds2 != null)
      nextDate.setMilliseconds(milliseconds2);
    onChange(nextDate, {
      lastValue: value,
      timeParts
    });
  }
  function focusNext(input, delta) {
    let nodes = qsa(ref.current, "* [data-focusable]");
    let next2 = nodes[nodes.indexOf(input) + delta];
    next2 == null ? void 0 : next2.focus();
    select(next2);
  }
  const {
    hours,
    minutes,
    seconds,
    milliseconds,
    meridiem
  } = timeParts;
  const showClear = !isEmptyValue(timeParts, precision);
  return import_react14.default.createElement(Widget_default, _extends15({}, props, {
    role: "group",
    ref
  }, focusEvents, {
    focused,
    disabled: disabled2,
    readOnly,
    className: (0, import_classnames10.default)(className, "rw-time-input rw-widget-input")
  }), import_react14.default.createElement(DateTimePartInput_default, {
    size: 2,
    pad: pad ? 2 : void 0,
    value: hours,
    disabled: disabled2,
    readOnly,
    "aria-label": "hours",
    min: getMin("hours"),
    max: getMax("hours"),
    ref: hourRef,
    emptyChar: emptyCharacter,
    onSelect: handleSelect,
    onChange: (e) => handleChange("hours", e),
    onKeyDown: (e) => handleKeyDown("hours", e)
  }), hoursAddon && import_react14.default.createElement("span", null, hoursAddon), import_react14.default.createElement(DateTimePartInput_default, {
    size: 2,
    pad: pad ? 2 : void 0,
    value: minutes,
    disabled: disabled2,
    readOnly,
    "aria-label": "minutes",
    min: getMin("minutes"),
    max: getMax("minutes"),
    emptyChar: emptyCharacter,
    onSelect: handleSelect,
    onChange: (e) => handleChange("minutes", e),
    onKeyDown: (e) => handleKeyDown("minutes", e)
  }), minsAddon && import_react14.default.createElement("span", null, minsAddon), (precision === "seconds" || precision === "milliseconds") && import_react14.default.createElement(import_react14.default.Fragment, null, import_react14.default.createElement(DateTimePartInput_default, {
    size: 2,
    pad: pad ? 2 : void 0,
    value: seconds,
    disabled: disabled2,
    readOnly,
    "aria-label": "seconds",
    min: getMin("seconds"),
    max: getMax("seconds"),
    emptyChar: emptyCharacter,
    onSelect: handleSelect,
    onChange: (e) => handleChange("seconds", e),
    onKeyDown: (e) => handleKeyDown("seconds", e)
  }), secsAddon && import_react14.default.createElement("span", null, secsAddon)), precision === "milliseconds" && import_react14.default.createElement(import_react14.default.Fragment, null, import_react14.default.createElement(DateTimePartInput_default, {
    size: 3,
    pad: pad ? 3 : void 0,
    value: milliseconds,
    disabled: disabled2,
    readOnly,
    "aria-label": "milliseconds",
    min: getMin("milliseconds"),
    max: getMax("milliseconds"),
    emptyChar: emptyCharacter,
    onSelect: handleSelect,
    onChange: (e) => handleChange("milliseconds", e),
    onKeyDown: (e) => handleKeyDown("milliseconds", e)
  }), millisecondsAddon && import_react14.default.createElement("span", null, millisecondsAddon)), use12HourClock && import_react14.default.createElement("div", {
    role: "listbox",
    "aria-label": "AM/PM",
    "aria-disabled": disabled2,
    "aria-readonly": readOnly,
    className: "rw-time-part-meridiem"
  }, import_react14.default.createElement("div", {
    "data-focusable": true,
    role: "option",
    "aria-atomic": true,
    "aria-selected": true,
    "aria-setsize": 2,
    "aria-live": "assertive",
    "aria-disabled": disabled2,
    "aria-readonly": readOnly,
    "aria-posinset": meridiem === "AM" ? 1 : 2,
    tabIndex: !disabled2 ? 0 : void 0,
    onFocus: handleSelect,
    onSelect: handleSelect,
    onKeyDown: (e) => handleKeyDown("meridiem", e)
  }, import_react14.default.createElement("abbr", null, meridiem))), !noClearButton && import_react14.default.createElement(Button_default, {
    label: "clear input",
    onClick: handleClear,
    disabled: disabled2 || readOnly,
    className: (0, import_classnames10.default)("rw-time-input-clear", showClear && "rw-show")
  }, times));
}
TimeInput.propTypes = propTypes3;
TimeInput.defaultProps = defaultProps;
var TimeInput_default = TimeInput;

// node_modules/react-widgets/esm/useTabTrap.js
var import_react15 = __toESM(require_react());
var defaultSelector = ["input", "textarea", "select", 'button:not([tabindex="-1"])', '[tabindex="0"]'].join(",");
var getDocument = () => document;
function useTabTrap(ref, selector = defaultSelector) {
  const startedRef = (0, import_react15.useRef)(false);
  useEventListener(getDocument, "keydown", (event) => {
    if (!startedRef.current || !ref.current || event.key !== "Tab") {
      return;
    }
    const tabbables = ref.current.querySelectorAll(selector);
    if (event.shiftKey && event.target === tabbables[0]) {
      tabbables[tabbables.length - 1].focus();
      event.preventDefault();
    } else if (!event.shiftKey && event.target === tabbables[tabbables.length - 1] || !ref.current.contains(event.target)) {
      tabbables[0].focus();
      event.preventDefault();
    }
  });
  return (0, import_react15.useMemo)(() => ({
    focus() {
      const tabbables = ref.current.querySelectorAll(selector);
      const first = tabbables[0];
      if (first)
        first.focus();
    },
    start() {
      startedRef.current = true;
    },
    stop() {
      startedRef.current = false;
    }
  }), [ref, selector]);
}

// node_modules/react-widgets/esm/DatePicker.js
var _excluded15 = ["id", "value", "onChange", "onSelect", "onToggle", "onKeyDown", "onKeyPress", "onCurrentDateChange", "inputProps", "calendarProps", "timeInputProps", "popupProps", "autoFocus", "tabIndex", "disabled", "readOnly", "className", "valueFormat", "valueDisplayFormat", "valueEditFormat", "containerClassName", "name", "selectIcon", "placeholder", "includeTime", "min", "max", "open", "dropUp", "parse", "messages", "formats", "currentDate", "popupTransition", "popupComponent", "timePrecision", "aria-labelledby", "aria-describedby"];
function _extends16() {
  _extends16 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends16.apply(this, arguments);
}
function _objectWithoutPropertiesLoose15(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var propTypes4 = {
  /**
   * @example ['valuePicker', [ ['new Date()', null] ]]
   */
  value: import_prop_types5.default.instanceOf(Date),
  /**
   * @example ['onChangePicker', [ ['new Date()', null] ]]
   */
  onChange: import_prop_types5.default.func,
  /**
   * @example ['openDate']
   */
  open: import_prop_types5.default.bool,
  onToggle: import_prop_types5.default.func,
  /**
   * Default current date at which the calendar opens. If none is provided, opens at today's date or the `value` date (if any).
   */
  currentDate: import_prop_types5.default.instanceOf(Date),
  /**
   * Change event Handler that is called when the currentDate is changed. The handler is called with the currentDate object.
   */
  onCurrentDateChange: import_prop_types5.default.func,
  onSelect: import_prop_types5.default.func,
  /**
   * The minimum Date that can be selected. Min only limits selection, it doesn't constrain the date values that
   * can be typed or pasted into the widget. If you need this behavior you can constrain values via
   * the `onChange` handler.
   *
   * @example ['prop', ['min', 'new Date()']]
   */
  min: import_prop_types5.default.instanceOf(Date),
  /**
   * The maximum Date that can be selected. Max only limits selection, it doesn't constrain the date values that
   * can be typed or pasted into the widget. If you need this behavior you can constrain values via
   * the `onChange` handler.
   *
   * @example ['prop', ['max', 'new Date()']]
   */
  max: import_prop_types5.default.instanceOf(Date),
  /**
   * A formatting options used to display the date value. This is a shorthand for
   * setting both `valueDisplayFormat` and `valueEditFormat`.
   */
  valueFormat: import_prop_types5.default.any,
  /**
   * A formatting options used to display the date value. For more information about formats
   * visit the [Localization page](./localization)
   *
   * ```tsx live
   * import { DatePicker } from 'react-widgets';
   *
   * <DatePicker
   *   defaultValue={new Date()}
   *   valueDisplayFormat={{ dateStyle: "medium" }}
   * />
   * ```
   */
  valueDisplayFormat: import_prop_types5.default.any,
  /**
   * A formatting options used while the date input has focus. Useful for showing a simpler format for inputing.
   * For more information about formats visit the [Localization page](./localization)
   *
   * ```tsx live
   * import { DatePicker } from 'react-widgets';
   *
   * <DatePicker
   *   defaultValue={new Date()}
   *   valueEditFormat={{ dateStyle: "short" }}
   *   valueDisplayFormat={{ dateStyle: "medium" }}
   * />
   * ```
   */
  valueEditFormat: import_prop_types5.default.any,
  /**
   * Enable the time list component of the picker.
   */
  includeTime: import_prop_types5.default.bool,
  timePrecision: import_prop_types5.default.oneOf(["minutes", "seconds", "milliseconds"]),
  timeInputProps: import_prop_types5.default.object,
  /** Specify the element used to render the calendar dropdown icon. */
  selectIcon: import_prop_types5.default.node,
  dropUp: import_prop_types5.default.bool,
  popupTransition: import_prop_types5.default.elementType,
  placeholder: import_prop_types5.default.string,
  name: import_prop_types5.default.string,
  autoFocus: import_prop_types5.default.bool,
  /**
   * @example ['disabled', ['new Date()']]
   */
  disabled: import_prop_types5.default.bool,
  /**
   * @example ['readOnly', ['new Date()']]
   */
  readOnly: import_prop_types5.default.bool,
  /**
   * Determines how the widget parses the typed date string into a Date object. You can provide an array of formats to try,
   * or provide a function that returns a date to handle parsing yourself. When `parse` is unspecified and
   * the `format` prop is a `string` parse will automatically use that format as its default.
   */
  parse: import_prop_types5.default.oneOfType([import_prop_types5.default.any, import_prop_types5.default.func]),
  /** @ignore */
  tabIndex: import_prop_types5.default.any,
  /** @ignore */
  "aria-labelledby": import_prop_types5.default.string,
  /** @ignore */
  "aria-describedby": import_prop_types5.default.string,
  /** @ignore */
  localizer: import_prop_types5.default.any,
  onKeyDown: import_prop_types5.default.func,
  onKeyPress: import_prop_types5.default.func,
  onBlur: import_prop_types5.default.func,
  onFocus: import_prop_types5.default.func,
  /** Adds a css class to the input container element. */
  containerClassName: import_prop_types5.default.string,
  calendarProps: import_prop_types5.default.object,
  inputProps: import_prop_types5.default.object,
  messages: import_prop_types5.default.shape({
    dateButton: import_prop_types5.default.string
  })
};
var defaultProps2 = Object.assign({}, Calendar_default.defaultProps, {
  min: new Date(1900, 0, 1),
  max: new Date(2099, 11, 31),
  selectIcon: calendar,
  formats: {}
});
var DatePicker = import_react16.default.forwardRef((uncontrolledProps, outerRef) => {
  const _useUncontrolled = useUncontrolled(uncontrolledProps, {
    open: "onToggle",
    value: "onChange",
    currentDate: "onCurrentDateChange"
  }), {
    id,
    value,
    onChange,
    onSelect,
    onToggle,
    onKeyDown,
    onKeyPress,
    onCurrentDateChange,
    inputProps,
    calendarProps,
    timeInputProps,
    popupProps,
    autoFocus,
    tabIndex,
    disabled: disabled2,
    readOnly,
    className,
    // @ts-ignore
    valueFormat,
    valueDisplayFormat = valueFormat,
    valueEditFormat = valueFormat,
    containerClassName,
    name,
    selectIcon,
    placeholder,
    includeTime = false,
    min,
    max,
    open,
    dropUp,
    parse,
    messages,
    formats,
    currentDate,
    popupTransition,
    popupComponent: Popup = Popup_default,
    timePrecision,
    "aria-labelledby": ariaLabelledby,
    "aria-describedby": ariaDescribedby
  } = _useUncontrolled, elementProps = _objectWithoutPropertiesLoose15(_useUncontrolled, _excluded15);
  const localizer = useLocalizer(messages, formats);
  const ref = (0, import_react16.useRef)(null);
  const calRef = (0, import_react16.useRef)(null);
  const tabTrap = useTabTrap(calRef);
  const inputId = useInstanceId(id, "_input");
  const dateId = useInstanceId(id, "_date");
  const currentFormat = includeTime ? "datetime" : "date";
  const toggle = useDropdownToggle(open, onToggle);
  const [focusEvents, focused] = useFocusManager(ref, uncontrolledProps, {
    didHandle(focused2) {
      if (!focused2) {
        toggle.close();
        tabTrap.stop();
      } else if (open) {
        tabTrap.focus();
      }
    }
  });
  const dateParser = (0, import_react16.useCallback)((str) => {
    var _localizer$parseDate, _ref;
    if (typeof parse == "function") {
      var _parse;
      return (_parse = parse(str, localizer)) != null ? _parse : null;
    }
    return (_localizer$parseDate = localizer.parseDate(str, (_ref = parse != null ? parse : valueEditFormat) != null ? _ref : valueDisplayFormat)) != null ? _localizer$parseDate : null;
  }, [localizer, parse, valueDisplayFormat, valueEditFormat]);
  const handleChange = useEventCallback((date, str, constrain) => {
    if (readOnly || disabled2)
      return;
    if (constrain)
      date = inRangeValue2(date);
    if (onChange) {
      if (date == null || value == null) {
        if (date != value)
          onChange(date, str);
      } else if (!dates_default.eq(date, value)) {
        onChange(date, str);
      }
    }
  });
  const handleKeyDown = useEventCallback((e) => {
    if (readOnly)
      return;
    notify(onKeyDown, [e]);
    if (e.defaultPrevented)
      return;
    if (e.key === "Escape" && open) {
      toggle.close();
    } else if (e.altKey) {
      if (e.key === "ArrowDown") {
        e.preventDefault();
        toggle.open();
      } else if (e.key === "ArrowUp") {
        e.preventDefault();
        toggle.close();
      }
    }
  });
  const handleKeyPress = useEventCallback((e) => {
    notify(onKeyPress, [e]);
    if (e.defaultPrevented)
      return;
  });
  const handleDateSelect = useEventCallback((date) => {
    var _ref$current;
    let dateTime = dates_default.merge(date, value, currentDate);
    let dateStr = formatDate(date);
    if (!includeTime)
      toggle.close();
    notify(onSelect, [dateTime, dateStr]);
    handleChange(dateTime, dateStr, true);
    (_ref$current = ref.current) == null ? void 0 : _ref$current.focus();
  });
  const handleTimeChange = useEventCallback((date) => {
    handleChange(date, formatDate(date), true);
  });
  const handleCalendarClick = useEventCallback((e) => {
    if (readOnly || disabled2)
      return;
    e.preventDefault();
    toggle();
  });
  const handleOpening = () => {
    tabTrap.start();
    requestAnimationFrame(() => {
      tabTrap.focus();
    });
  };
  const handleClosing = () => {
    tabTrap.stop();
    if (focused)
      focus();
  };
  function focus() {
    var _calRef$current, _ref$current2;
    if (open)
      (_calRef$current = calRef.current) == null ? void 0 : _calRef$current.focus();
    else
      (_ref$current2 = ref.current) == null ? void 0 : _ref$current2.focus();
  }
  function inRangeValue2(value2) {
    if (value2 == null)
      return value2;
    return dates_default.max(dates_default.min(value2, max), min);
  }
  function formatDate(date) {
    return date instanceof Date && !isNaN(date.getTime()) ? localizer.formatDate(date, currentFormat) : "";
  }
  (0, import_react16.useImperativeHandle)(outerRef, () => ({
    focus
  }));
  let shouldRenderList = useFirstFocusedRender(focused, open);
  const inputReadOnly = (inputProps == null ? void 0 : inputProps.readOnly) != null ? inputProps == null ? void 0 : inputProps.readOnly : readOnly;
  return import_react16.default.createElement(Widget_default, _extends16({}, elementProps, {
    defaultValue: void 0,
    open: !!open,
    dropUp,
    focused,
    disabled: disabled2,
    readOnly,
    onKeyDown: handleKeyDown,
    onKeyPress: handleKeyPress
  }, focusEvents, {
    className: (0, import_classnames11.default)(className, "rw-date-picker")
  }), import_react16.default.createElement(WidgetPicker_default, {
    className: containerClassName
  }, import_react16.default.createElement(DatePickerInput_default, _extends16({}, inputProps, {
    id: inputId,
    ref,
    role: "combobox",
    name,
    value,
    tabIndex,
    autoFocus,
    placeholder,
    disabled: disabled2,
    readOnly: inputReadOnly,
    formatter: currentFormat,
    displayFormat: valueDisplayFormat,
    editFormat: valueEditFormat,
    editing: focused,
    localizer,
    parse: dateParser,
    onChange: handleChange,
    "aria-haspopup": true,
    "aria-labelledby": ariaLabelledby,
    "aria-describedby": ariaDescribedby,
    "aria-expanded": !!open,
    "aria-owns": dateId
  })), import_react16.default.createElement(InputAddon_default, {
    icon: selectIcon,
    label: localizer.messages.dateButton(),
    disabled: disabled2 || readOnly,
    onClick: handleCalendarClick
  })), !!shouldRenderList && import_react16.default.createElement(Popup, _extends16({}, popupProps, {
    dropUp,
    open,
    role: "dialog",
    ref: calRef,
    id: dateId,
    className: "rw-calendar-popup",
    transition: popupTransition,
    onEntering: handleOpening,
    onExited: handleClosing
  }), import_react16.default.createElement(Calendar_default, _extends16({
    min,
    max,
    bordered: false
  }, calendarProps, {
    messages: Object.assign({}, messages, calendarProps == null ? void 0 : calendarProps.messages),
    tabIndex: -1,
    value,
    autoFocus: false,
    onChange: handleDateSelect,
    currentDate,
    onCurrentDateChange,
    "aria-hidden": !open,
    "aria-live": "polite",
    "aria-labelledby": inputId
  })), includeTime && import_react16.default.createElement(TimeInput_default, _extends16({}, timeInputProps, {
    value,
    precision: timePrecision,
    onChange: handleTimeChange,
    datePart: currentDate
  }))));
});
DatePicker.displayName = "DatePicker";
DatePicker.propTypes = propTypes4;
DatePicker.defaultProps = defaultProps2;
var DatePicker_default = DatePicker;

// node_modules/react-widgets/esm/Listbox.js
var import_prop_types6 = __toESM(require_prop_types());
var import_classnames12 = __toESM(require_classnames());
var import_react17 = __toESM(require_react());
var _excluded16 = ["defaultValue", "value", "onChange", "textField", "dataKey", "data", "onKeyDown", "disabled", "readOnly", "onBlur", "onFocus", "multiple"];
function _extends17() {
  _extends17 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends17.apply(this, arguments);
}
function _objectWithoutPropertiesLoose16(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var propTypes5 = {
  data: import_prop_types6.default.array,
  dataKey: accessor,
  textField: accessor,
  onSelect: import_prop_types6.default.func,
  onMove: import_prop_types6.default.func,
  onHoverOption: import_prop_types6.default.func,
  optionComponent: import_prop_types6.default.elementType,
  renderItem: import_prop_types6.default.func,
  renderGroup: import_prop_types6.default.func,
  focusedItem: import_prop_types6.default.any,
  selectedItem: import_prop_types6.default.any,
  searchTerm: import_prop_types6.default.string,
  /**
   * @example false
   */
  disabled: disabled.acceptsArray,
  messages: import_prop_types6.default.shape({
    emptyList: import_prop_types6.default.func.isRequired
  })
};
var Listbox = import_react17.default.forwardRef(function Listbox2(_ref, _outerRef) {
  let {
    defaultValue,
    value: propsValue,
    onChange: propsOnChange,
    textField,
    dataKey,
    data,
    onKeyDown,
    disabled: disabled2,
    readOnly,
    onBlur,
    onFocus,
    multiple
  } = _ref, props = _objectWithoutPropertiesLoose16(_ref, _excluded16);
  const [value, onChange] = useUncontrolledProp(propsValue, defaultValue, propsOnChange);
  const accessors = useAccessors(textField, dataKey);
  const dataItems = (0, import_react17.useMemo)(() => makeArray(value, multiple).map((item) => accessors.findOrSelf(data, item)), [value, multiple, accessors, data]);
  const ref = (0, import_react17.useRef)(null);
  const lastItemRef = (0, import_react17.useRef)(dataItems[dataItems.length - 1]);
  const list = useFocusList({
    scope: ref,
    anchorItem: lastItemRef.current
  });
  const isDisabled = disabled2 === true;
  const handleChange = (dataItem, meta) => {
    if (isDisabled || readOnly)
      return;
    lastItemRef.current = meta.dataItem;
    onChange(dataItem, meta);
  };
  const handleSelect = useHandleSelect(!!multiple, dataItems, handleChange);
  const [focusEvents, focused] = useFocusManager(ref, {
    disabled: isDisabled,
    onBlur,
    onFocus
  }, {
    didHandle(focused2) {
      if (!focused2) {
        list.focus(void 0);
      } else {
        focus({
          preventScroll: true
        });
      }
    }
  });
  function focus(opts) {
    if (ref.current)
      ref.current.focus(opts);
  }
  const handleKeyDown = (e) => {
    if (isDisabled || readOnly)
      return;
    let {
      key,
      shiftKey
    } = e;
    notify(onKeyDown, [e]);
    if (e.defaultPrevented)
      return;
    if (key === "End" && !shiftKey) {
      e.preventDefault();
      list.focus(list.last());
    } else if (key === "Home" && !shiftKey) {
      e.preventDefault();
      list.focus(list.first());
    } else if (key === "Enter" || key === " ") {
      e.preventDefault();
      if (list.getFocused())
        handleSelect(list.getFocused(), e);
    } else if (key === "ArrowDown") {
      e.preventDefault();
      list.focus(list.next());
    } else if (key === "ArrowUp") {
      e.preventDefault();
      list.focus(list.prev());
    }
  };
  const widgetProps = useWidgetProps({
    focused,
    readOnly,
    disabled: isDisabled,
    className: (0, import_classnames12.default)(props.className, "rw-listbox rw-widget-input rw-widget")
  });
  return import_react17.default.createElement(FocusListContext.Provider, {
    value: list.context
  }, import_react17.default.createElement(List_default, _extends17({}, props, widgetProps, {
    disabled: disabled2,
    tabIndex: isDisabled ? -1 : 0,
    data,
    elementRef: ref,
    value: dataItems,
    multiple,
    accessors
  }, focusEvents, {
    onChange: handleChange,
    onKeyDown: handleKeyDown
  })));
});
Listbox.displayName = "Listbox";
Listbox.propTypes = propTypes5;
var Listbox_default = Listbox;

// node_modules/react-widgets/esm/Multiselect.js
var import_classnames14 = __toESM(require_classnames());

// node_modules/dom-helpers/esm/closest.js
function closest(node2, selector, stopAt) {
  if (node2.closest && !stopAt)
    node2.closest(selector);
  var nextNode = node2;
  do {
    if (matches(nextNode, selector))
      return nextNode;
    nextNode = nextNode.parentElement;
  } while (nextNode && nextNode !== stopAt && nextNode.nodeType === document.ELEMENT_NODE);
  return null;
}

// node_modules/react-widgets/esm/Multiselect.js
var import_prop_types8 = __toESM(require_prop_types());
var import_react21 = __toESM(require_react());

// node_modules/react-widgets/esm/MultiselectInput.js
var import_prop_types7 = __toESM(require_prop_types());
var import_react18 = __toESM(require_react());
var _excluded17 = ["disabled", "readOnly"];
function _extends18() {
  _extends18 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends18.apply(this, arguments);
}
function _objectWithoutPropertiesLoose17(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var propTypes6 = {
  value: import_prop_types7.default.string,
  placeholder: import_prop_types7.default.string,
  maxLength: import_prop_types7.default.number,
  onChange: import_prop_types7.default.func.isRequired,
  disabled,
  readOnly: disabled
};
var MultiselectInput = import_react18.default.forwardRef((_ref, ref) => {
  let {
    disabled: disabled2,
    readOnly
  } = _ref, props = _objectWithoutPropertiesLoose17(_ref, _excluded17);
  let size = Math.max(String(props.value || props.placeholder || "").length, 1) + 1;
  return import_react18.default.createElement("input", _extends18({
    spellCheck: "false",
    autoCapitalize: "off"
  }, props, {
    size,
    ref,
    autoComplete: "off",
    className: "rw-multiselect-input",
    "aria-disabled": disabled2,
    "aria-readonly": readOnly,
    disabled: disabled2,
    readOnly
  }));
});
MultiselectInput.displayName = "MultiselectInput";
MultiselectInput.propTypes = propTypes6;
var MultiselectInput_default = MultiselectInput;

// node_modules/react-widgets/esm/MultiselectTagList.js
var import_react20 = __toESM(require_react());

// node_modules/react-widgets/esm/MultiselectTag.js
var import_classnames13 = __toESM(require_classnames());
var import_react19 = __toESM(require_react());
function MultiselectTag({
  className,
  children,
  style,
  label,
  disabled: disabled2,
  readOnly,
  onRemove,
  clearTagIcon,
  dataItem
}) {
  const [ref, focused, id] = useListOption(dataItem);
  const handleRemove = (event) => {
    if (!disabled2)
      onRemove(dataItem, event);
  };
  return import_react19.default.createElement("div", {
    ref,
    role: "option",
    id,
    "data-rw-option": "",
    "data-rw-focusable": disabled2 ? void 0 : "",
    "data-rw-focused": focused ? "" : void 0,
    className: (0, import_classnames13.default)(className, "rw-multiselect-tag", disabled2 && "rw-state-disabled", focused && !disabled2 && "rw-state-focus"),
    style
  }, import_react19.default.createElement("span", {
    className: "rw-multiselect-tag-label"
  }, children), import_react19.default.createElement("button", {
    type: "button",
    tabIndex: -1,
    onClick: handleRemove,
    onTouchEnd: handleRemove,
    disabled: disabled2 || readOnly,
    className: "rw-multiselect-tag-btn",
    "aria-label": label || "Remove item"
  }, clearTagIcon));
}
var MultiselectTag_default = MultiselectTag;

// node_modules/react-widgets/esm/MultiselectTagList.js
function MultiselectTagList({
  id,
  value,
  textAccessor,
  label,
  disabled: disabled2,
  readOnly,
  onDelete,
  children,
  clearTagIcon,
  renderTagValue,
  tagOptionComponent: TagOption = MultiselectTag_default
}) {
  return import_react20.default.createElement("div", {
    id,
    role: "listbox",
    "aria-label": label,
    "aria-multiselectable": "true",
    "aria-orientation": "horizontal",
    className: "rw-multiselect-taglist"
  }, value.map((item, i) => {
    const itemDisabled = Array.isArray(disabled2) ? disabled2.includes(item) : !!disabled2;
    return import_react20.default.createElement(TagOption, {
      key: i,
      dataItem: item,
      onRemove: onDelete,
      clearTagIcon,
      disabled: itemDisabled,
      readOnly
    }, renderTagValue ? renderTagValue({
      item
    }) : textAccessor(item));
  }), children);
}
var MultiselectTagList_default = MultiselectTagList;

// node_modules/react-widgets/esm/Multiselect.js
var _excluded18 = ["dataKey", "textField", "autoFocus", "id", "value", "defaultValue", "onChange", "open", "defaultOpen", "onToggle", "focusFirstItem", "searchTerm", "defaultSearchTerm", "onSearch", "filter", "allowCreate", "className", "containerClassName", "placeholder", "busy", "disabled", "readOnly", "selectIcon", "clearTagIcon", "busySpinner", "dropUp", "tabIndex", "popupTransition", "showPlaceholderWithValues", "showSelectedItemsInList", "onSelect", "onCreate", "onKeyDown", "onBlur", "onFocus", "inputProps", "listProps", "popupProps", "renderListItem", "renderListGroup", "renderTagValue", "optionComponent", "tagOptionComponent", "groupBy", "listComponent", "popupComponent", "tagListComponent", "data", "messages"];
function _extends19() {
  _extends19 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends19.apply(this, arguments);
}
function _objectWithoutPropertiesLoose18(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var ENTER = 13;
var INSERT = "insert";
var REMOVE = "remove";
var propTypes7 = {
  data: import_prop_types8.default.array,
  //-- controlled props --
  value: import_prop_types8.default.array,
  /**
   * @type {function (
   *  dataItems: ?any[],
   *  metadata: {
   *    dataItem: any,
   *    action: 'insert' | 'remove',
   *    originalEvent: SyntheticEvent,
   *    lastValue: ?any[],
   *    searchTerm: ?string
   *  }
   * ): void}
   */
  onChange: import_prop_types8.default.func,
  searchTerm: import_prop_types8.default.string,
  /**
   * @type {function (
   *  searchTerm: ?string,
   *  metadata: {
   *    action: 'clear' | 'input',
   *    lastSearchTerm: ?string,
   *    originalEvent: SyntheticEvent,
   *  }
   * ): void}
   */
  onSearch: import_prop_types8.default.func,
  open: import_prop_types8.default.bool,
  handleOpen: import_prop_types8.default.func,
  //-------------------------------------------
  dataKey: accessor,
  textField: accessor,
  renderTagValue: import_prop_types8.default.func,
  renderListItem: import_prop_types8.default.func,
  renderListGroup: import_prop_types8.default.func,
  groupBy: accessor,
  allowCreate: import_prop_types8.default.oneOf([true, false, "onFilter"]),
  /**
   *
   * @type { (dataItem: ?any, metadata: { originalEvent: SyntheticEvent }) => void }
   */
  onSelect: import_prop_types8.default.func,
  /**
   * @type { (searchTerm: string) => void }
   */
  onCreate: import_prop_types8.default.func,
  busy: import_prop_types8.default.bool,
  /** Specify the element used to render the select (down arrow) icon. */
  selectIcon: import_prop_types8.default.node,
  /** Specify the element used to render tag clear icons. */
  clearTagIcon: import_prop_types8.default.node,
  /** Specify the element used to render the busy indicator */
  busySpinner: import_prop_types8.default.node,
  dropUp: import_prop_types8.default.bool,
  popupTransition: import_prop_types8.default.elementType,
  /** Adds a css class to the input container element. */
  containerClassName: import_prop_types8.default.string,
  inputProps: import_prop_types8.default.object,
  listProps: import_prop_types8.default.object,
  autoFocus: import_prop_types8.default.bool,
  placeholder: import_prop_types8.default.string,
  /** Continue to show the input placeholder even if tags are selected */
  showPlaceholderWithValues: import_prop_types8.default.bool,
  /** Continue to show the selected items in the dropdown list */
  showSelectedItemsInList: import_prop_types8.default.bool,
  disabled: disabled.acceptsArray,
  readOnly: disabled,
  messages: import_prop_types8.default.shape({
    open: message,
    emptyList: message,
    emptyFilter: message,
    createOption: message,
    tagsLabel: message,
    selectedItems: message,
    noneSelected: message,
    removeLabel: message
  })
};
var EMPTY_ARRAY = [];
function useMultiselectData(value = EMPTY_ARRAY, data, accessors, filter, searchTerm, showSelectedItemsInList) {
  data = (0, import_react21.useMemo)(() => showSelectedItemsInList ? data : data.filter((i) => !value.some((v) => accessors.matches(i, v))), [data, showSelectedItemsInList, value, accessors]);
  return [useFilteredData(data, filter || false, searchTerm, accessors.text), data.length];
}
var Multiselect = import_react21.default.forwardRef(function Multiselect2(_ref, outerRef) {
  let {
    dataKey,
    textField,
    autoFocus,
    id,
    value,
    defaultValue = [],
    onChange,
    open,
    defaultOpen = false,
    onToggle,
    focusFirstItem = false,
    searchTerm,
    defaultSearchTerm = "",
    onSearch,
    filter = "startsWith",
    allowCreate = false,
    className,
    containerClassName,
    placeholder,
    busy,
    disabled: disabled2,
    readOnly,
    selectIcon,
    clearTagIcon = times,
    busySpinner,
    dropUp,
    tabIndex,
    popupTransition,
    showPlaceholderWithValues = false,
    showSelectedItemsInList = false,
    onSelect,
    onCreate,
    onKeyDown,
    onBlur,
    onFocus,
    inputProps,
    listProps,
    popupProps,
    renderListItem,
    renderListGroup,
    renderTagValue,
    optionComponent,
    tagOptionComponent,
    groupBy,
    listComponent: ListComponent = List_default,
    popupComponent: Popup = Popup_default,
    tagListComponent: TagList = MultiselectTagList_default,
    data: rawData = [],
    messages: userMessages
  } = _ref, elementProps = _objectWithoutPropertiesLoose18(_ref, _excluded18);
  let [currentValue, handleChange] = useUncontrolledProp(value, defaultValue, onChange);
  const [currentOpen, handleOpen] = useUncontrolledProp(open, defaultOpen, onToggle);
  const [currentSearch, handleSearch] = useUncontrolledProp(searchTerm, defaultSearchTerm, onSearch);
  const ref = (0, import_react21.useRef)(null);
  const inputRef = (0, import_react21.useRef)(null);
  const listRef = (0, import_react21.useRef)(null);
  const inputId = useInstanceId(id, "_input");
  const tagsId = useInstanceId(id, "_taglist");
  const listId = useInstanceId(id, "_listbox");
  const createId = useInstanceId(id, "_createlist_option");
  const activeTagId = useInstanceId(id, "_taglist_active_tag");
  const activeOptionId = useInstanceId(id, "_listbox_active_option");
  const accessors = useAccessors(textField, dataKey);
  const messages = useMessagesWithDefaults(userMessages);
  const toggle = useDropdownToggle(currentOpen, handleOpen);
  const isDisabled = disabled2 === true;
  const isReadOnly = !!readOnly;
  const [focusEvents, focused] = useFocusManager(ref, {
    disabled: isDisabled,
    onBlur,
    onFocus
  }, {
    didHandle(focused2, event) {
      if (focused2)
        return focus();
      toggle.close();
      clearSearch(event);
      tagList.focus(null);
    }
  });
  const dataItems = (0, import_react21.useMemo)(() => currentValue.map((item) => accessors.findOrSelf(rawData, item)), [rawData, currentValue, accessors]);
  const [data, lengthWithoutValues] = useMultiselectData(dataItems, rawData, accessors, currentOpen ? filter : false, currentSearch, showSelectedItemsInList);
  const list = useFocusList({
    scope: ref,
    scopeSelector: ".rw-popup",
    focusFirstItem,
    activeId: activeOptionId,
    anchorItem: currentOpen ? dataItems[dataItems.length - 1] : void 0
  });
  const tagList = useFocusList({
    scope: ref,
    scopeSelector: ".rw-multiselect-taglist",
    activeId: activeTagId
  });
  const showCreateOption = canShowCreate(allowCreate, {
    searchTerm: currentSearch,
    data,
    dataItems,
    accessors
  });
  const focusedTag = tagList.getFocused();
  (0, import_react21.useEffect)(() => {
    if (currentOpen)
      return;
    setActiveDescendant(inputRef.current, focusedTag ? activeTagId : "");
  }, [activeTagId, currentOpen, focusedTag]);
  const focusedItem = list.getFocused();
  (0, import_react21.useEffect)(() => {
    if (!currentOpen)
      return;
    setActiveDescendant(inputRef.current, focusedItem ? activeOptionId : "");
  }, [activeOptionId, currentOpen, focusedItem]);
  const handleDelete = (dataItem, event) => {
    if (isDisabled || readOnly || tagList.size() === 0)
      return;
    focus();
    change(dataItem, event, REMOVE);
  };
  const deletingRef = (0, import_react21.useRef)(false);
  const handleSearchKeyDown = (e) => {
    if (e.key === "Backspace" && e.currentTarget.value && !deletingRef.current)
      deletingRef.current = true;
  };
  const handleSearchKeyUp = (e) => {
    if (e.key === "Backspace" && deletingRef.current) {
      deletingRef.current = false;
    }
  };
  const handleInputChange = (e) => {
    search(e.target.value, e, "input");
    toggle.open();
  };
  const handleClick = (e) => {
    if (isDisabled || readOnly)
      return;
    e.preventDefault();
    focus();
    if (closest(e.target, ".rw-select") && currentOpen) {
      toggle.close();
    } else
      toggle.open();
  };
  const handleDoubleClick = () => {
    if (isDisabled || !inputRef.current)
      return;
    focus();
    if (inputRef.current)
      inputRef.current.select();
  };
  const handleSelect = (dataItem, originalEvent) => {
    if (dataItem === void 0)
      return;
    originalEvent.preventDefault();
    if (dataItem === CREATE_OPTION) {
      handleCreate(originalEvent);
      return;
    }
    notify(onSelect, [dataItem, {
      originalEvent
    }]);
    if (!showSelectedItemsInList || !dataItems.includes(dataItem)) {
      change(dataItem, originalEvent, INSERT);
    } else {
      change(dataItem, originalEvent, REMOVE);
    }
    focus();
  };
  const handleCreate = (event) => {
    notify(onCreate, [currentSearch]);
    clearSearch(event);
    focus();
  };
  const handleKeyDown = (event) => {
    if (readOnly) {
      event.preventDefault();
      return;
    }
    let {
      key,
      keyCode,
      altKey,
      ctrlKey
    } = event;
    notify(onKeyDown, [event]);
    if (event.defaultPrevented)
      return;
    if (key === "ArrowDown") {
      event.preventDefault();
      if (!currentOpen) {
        toggle.open();
        return;
      }
      list.focus(list.next());
      tagList.focus(null);
    } else if (key === "ArrowUp" && (currentOpen || altKey)) {
      event.preventDefault();
      if (altKey) {
        toggle.close();
        return;
      }
      list.focus(list.prev());
      tagList.focus(null);
    } else if (key === "End") {
      event.preventDefault();
      if (currentOpen) {
        list.focus(list.last());
        tagList.focus(null);
      } else {
        tagList.focus(tagList.last());
        list.focus(null);
      }
    } else if (key === "Home") {
      event.preventDefault();
      if (currentOpen)
        list.focus(list.first());
      else
        list.focus(tagList.first());
    } else if (currentOpen && keyCode === ENTER) {
      event.preventDefault();
      if (ctrlKey && showCreateOption) {
        return handleCreate(event);
      }
      handleSelect(list.getFocused(), event);
    } else if (key === "Escape") {
      if (currentOpen)
        toggle.close();
      else
        tagList.focus(null);
    } else if (!currentSearch && !deletingRef.current) {
      if (key === "ArrowLeft") {
        tagList.focus(tagList.prev({
          behavior: "loop"
        }));
      } else if (key === "ArrowRight") {
        tagList.focus(tagList.next({
          behavior: "loop"
        }));
      } else if (key === "Delete" && tagList.getFocused()) {
        handleDelete(tagList.getFocused(), event);
      } else if (key === "Backspace") {
        handleDelete(tagList.toDataItem(tagList.last()), event);
      } else if (key === " " && !currentOpen) {
        event.preventDefault();
        toggle.open();
      }
    }
  };
  function change(dataItem, originalEvent, action) {
    let nextDataItems = dataItems;
    switch (action) {
      case INSERT:
        nextDataItems = nextDataItems.concat(dataItem);
        break;
      case REMOVE:
        nextDataItems = nextDataItems.filter((d) => d !== dataItem);
        break;
    }
    handleChange(nextDataItems, {
      action,
      dataItem,
      originalEvent,
      searchTerm: currentSearch,
      lastValue: currentValue
    });
    clearSearch(originalEvent);
  }
  function clearSearch(originalEvent) {
    search("", originalEvent, "clear");
  }
  function search(nextSearchTerm, originalEvent, action = "input") {
    if (nextSearchTerm !== currentSearch)
      handleSearch(nextSearchTerm, {
        action,
        originalEvent,
        lastSearchTerm: currentSearch
      });
  }
  function focus() {
    if (inputRef.current)
      inputRef.current.focus();
  }
  (0, import_react21.useImperativeHandle)(outerRef, () => ({
    focus
  }));
  let shouldRenderPopup = useFirstFocusedRender(focused, currentOpen);
  let shouldRenderTags = !!dataItems.length;
  let inputOwns = `${listId} ` + (shouldRenderTags ? tagsId : "") + (showCreateOption ? createId : "");
  return import_react21.default.createElement(Widget_default, _extends19({}, elementProps, {
    ref,
    open: currentOpen,
    dropUp,
    focused,
    disabled: isDisabled,
    readOnly: isReadOnly,
    onKeyDown: handleKeyDown
  }, focusEvents, {
    className: (0, import_classnames14.default)(className, "rw-multiselect")
  }), import_react21.default.createElement(WidgetPicker_default, {
    onClick: handleClick,
    onTouchEnd: handleClick,
    onDoubleClick: handleDoubleClick,
    className: (0, import_classnames14.default)(containerClassName, "rw-widget-input")
  }, import_react21.default.createElement(FocusListContext.Provider, {
    value: tagList.context
  }, import_react21.default.createElement(TagList, {
    id: tagsId,
    textAccessor: accessors.text,
    clearTagIcon,
    label: messages.tagsLabel(),
    value: dataItems,
    readOnly: isReadOnly,
    disabled: disabled2,
    onDelete: handleDelete,
    tagOptionComponent,
    renderTagValue
  }, import_react21.default.createElement(MultiselectInput_default, _extends19({}, inputProps, {
    role: "combobox",
    autoFocus,
    tabIndex: tabIndex || 0,
    "aria-expanded": !!currentOpen,
    "aria-busy": !!busy,
    "aria-owns": inputOwns,
    "aria-controls": listId,
    "aria-haspopup": "listbox",
    "aria-autocomplete": "list",
    value: currentSearch,
    disabled: isDisabled,
    readOnly: isReadOnly,
    placeholder: (currentValue.length && !showPlaceholderWithValues ? "" : placeholder) || "",
    onKeyDown: handleSearchKeyDown,
    onKeyUp: handleSearchKeyUp,
    onChange: handleInputChange,
    ref: inputRef
  })))), import_react21.default.createElement(PickerCaret_default, {
    busy,
    spinner: busySpinner,
    icon: selectIcon,
    visible: focused
  })), import_react21.default.createElement(FocusListContext.Provider, {
    value: list.context
  }, shouldRenderPopup && import_react21.default.createElement(Popup, _extends19({}, popupProps, {
    dropUp,
    open: currentOpen,
    transition: popupTransition,
    onEntering: () => listRef.current.scrollIntoView()
  }), import_react21.default.createElement(ListComponent, _extends19({}, listProps, {
    id: listId,
    data,
    tabIndex: -1,
    disabled: disabled2,
    searchTerm: currentSearch,
    accessors,
    renderItem: renderListItem,
    renderGroup: renderListGroup,
    value: dataItems,
    groupBy,
    optionComponent,
    onChange: (d, meta) => handleSelect(d, meta.originalEvent),
    "aria-live": "polite",
    "aria-labelledby": inputId,
    "aria-hidden": !currentOpen,
    ref: listRef,
    messages: {
      emptyList: lengthWithoutValues ? messages.emptyFilter : messages.emptyList
    }
  })), showCreateOption && import_react21.default.createElement(AddToListOption_default, {
    onSelect: handleCreate
  }, messages.createOption(currentValue, currentSearch)))));
});
Multiselect.displayName = "Multiselect";
Multiselect.propTypes = propTypes7;
var Multiselect_default = Multiselect;

// node_modules/react-widgets/esm/NumberPicker.js
var import_classnames15 = __toESM(require_classnames());
var import_prop_types10 = __toESM(require_prop_types());
var import_react23 = __toESM(require_react());

// node_modules/react-widgets/esm/NumberInput.js
var import_prop_types9 = __toESM(require_prop_types());
var import_react22 = __toESM(require_react());
var import_react_dom = __toESM(require_react_dom());
var _excluded19 = ["disabled", "readOnly", "placeholder", "innerRef", "min", "max", "localizer", "editing"];
function _extends20() {
  _extends20 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends20.apply(this, arguments);
}
function _objectWithoutPropertiesLoose19(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var isSign = (val) => (val || "").trim() === "-";
function isPaddedZeros(str, localizer) {
  let localeChar = localizer.decimalCharacter();
  let [_, decimals] = str.split(localeChar);
  return !!(decimals && decimals.match(/0+$/));
}
function isAtDelimiter(str, localizer) {
  let localeChar = localizer.decimalCharacter();
  let lastIndex = str.length - 1;
  if (str.length < 1)
    return false;
  let char = str[lastIndex];
  return !!(char === localeChar && str.indexOf(char) === lastIndex);
}
var NumberPickerInput = class extends import_react22.default.Component {
  constructor(...args) {
    super(...args);
    this.state = {};
    this.handleBlur = (event) => {
      let str = this.state.stringValue;
      let number = this.parseNumber(str);
      if (this.isIntermediateValue(number, str)) {
        if (isNaN(number)) {
          number = null;
        }
        this.props.onChange(number, event);
      }
    };
    this.handleChange = (event) => {
      let {
        value,
        onChange
      } = this.props;
      let stringValue = event.target.value, numberValue = this.parseNumber(stringValue);
      let isIntermediate = this.isIntermediateValue(numberValue, stringValue);
      if (stringValue == null || stringValue.trim() === "") {
        this.setStringValue("");
        onChange(null, event);
        return;
      }
      if (isIntermediate) {
        this.setStringValue(stringValue);
      } else if (numberValue !== value) {
        onChange(numberValue, event);
      } else if (stringValue != this.state.stringValue) {
        this.setStringValue(stringValue);
      }
    };
  }
  getSnapshotBeforeUpdate({
    editing
  }) {
    return {
      reselectText: !editing && this.props.editing && this.isSelectingAllText()
    };
  }
  static getDerivedStateFromProps(nextProps, prevState) {
    let {
      value,
      editing,
      localizer
    } = nextProps;
    let decimal = localizer.decimalCharacter();
    const stringValue = value == null || isNaN(value) ? "" : editing ? ("" + value).replace(".", decimal) : localizer.formatNumber(
      value
      /*, 'default'*/
    );
    if (prevState.lastValueFromProps !== stringValue)
      return {
        stringValue,
        lastValueFromProps: stringValue
      };
    return null;
  }
  componentDidUpdate(_, __, {
    reselectText
  }) {
    if (reselectText)
      (0, import_react_dom.findDOMNode)(this).select();
  }
  // this intermediate state is for when one runs into
  // the decimal or are typing the number
  setStringValue(stringValue) {
    this.setState({
      stringValue
    });
  }
  isIntermediateValue(num, str) {
    let {
      localizer,
      min
    } = this.props;
    return !!(num < min || isSign(str) || isAtDelimiter(str, localizer) || isPaddedZeros(str, localizer));
  }
  isSelectingAllText() {
    const node2 = canUseDOM_default && (0, import_react_dom.findDOMNode)(this);
    return canUseDOM_default && activeElement() === node2 && node2.selectionStart === 0 && node2.selectionEnd === node2.value.length;
  }
  parseNumber(strVal) {
    let {
      localizer,
      parse: userParse
    } = this.props;
    if (userParse)
      return userParse(strVal, localizer);
    return localizer.parseNumber(strVal);
  }
  render() {
    let _this$props = this.props, {
      disabled: disabled2,
      readOnly,
      placeholder,
      // eslint-disable-next-line react/prop-types
      innerRef,
      min,
      max
    } = _this$props, props = _objectWithoutPropertiesLoose19(_this$props, _excluded19);
    let value = this.state.stringValue;
    return import_react22.default.createElement(Input_default, _extends20({}, props, {
      ref: innerRef,
      inputMode: "numeric",
      className: "rw-widget-input",
      onChange: this.handleChange,
      onBlur: this.handleBlur,
      "aria-valuenow": value,
      "aria-valuemin": isFinite(min) ? min : void 0,
      "aria-valuemax": isFinite(max) ? max : void 0,
      disabled: disabled2,
      readOnly,
      placeholder,
      value
    }));
  }
};
NumberPickerInput.defaultProps = {
  value: null,
  editing: false
};
NumberPickerInput.propTypes = {
  value: import_prop_types9.default.number,
  editing: import_prop_types9.default.bool,
  placeholder: import_prop_types9.default.string,
  localizer: import_prop_types9.default.object.isRequired,
  parse: import_prop_types9.default.func,
  min: import_prop_types9.default.number,
  max: import_prop_types9.default.number,
  disabled,
  readOnly: disabled,
  onChange: import_prop_types9.default.func.isRequired
};
var NumberInput_default = NumberPickerInput;

// node_modules/react-widgets/esm/NumberPicker.js
var _excluded20 = ["className", "containerClassName", "disabled", "readOnly", "value", "min", "max", "incrementIcon", "decrementIcon", "placeholder", "autoFocus", "tabIndex", "parse", "name", "onChange", "messages", "format", "onKeyDown", "onKeyPress", "onKeyUp", "inputProps", "precision", "step"];
function _extends21() {
  _extends21 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends21.apply(this, arguments);
}
function _objectWithoutPropertiesLoose20(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function createInterval(callback) {
  let fn;
  let id;
  const cancel = () => clearTimeout(id);
  id = window.setTimeout(fn = () => {
    id = window.setTimeout(fn, 35);
    callback();
  }, 500);
  return cancel;
}
function clamp2(value, min, max) {
  max = max == null ? Infinity : max;
  min = min == null ? -Infinity : min;
  if (value == null || value === "")
    return null;
  return Math.max(Math.min(typeof value == "string" ? parseInt(value) : value, max), min);
}
var propTypes8 = {
  /**
   * @example ['valuePicker', [ [1, null] ]]
   */
  value: import_prop_types10.default.number,
  /**
   * @example ['onChangePicker', [ [1, null] ]]
   */
  onChange: import_prop_types10.default.func,
  /**
   * The minimum number that the NumberPicker value.
   * @example ['prop', ['min', 0]]
   */
  min: import_prop_types10.default.number,
  /**
   * The maximum number that the NumberPicker value.
   *
   * @example ['prop', ['max', 0]]
   */
  max: import_prop_types10.default.number,
  /**
   * Amount to increase or decrease value when using the spinner buttons.
   *
   * @example ['prop', ['step', 5]]
   */
  step: import_prop_types10.default.number,
  /**
   * Specify how precise the `value` should be when typing, incrementing, or decrementing the value.
   * When empty, precision is parsed from the current `format` and culture.
   */
  precision: import_prop_types10.default.oneOfType([import_prop_types10.default.number, import_prop_types10.default.oneOf(["auto"])]),
  /**
   * A format string used to display the number value. Localizer dependent, read about [localization](localization) for more info.
   *
   * @example ['prop', { max: 1, min: -1 , defaultValue: 0.2585, format: "{ style: 'percent' }" }]
   */
  format: import_prop_types10.default.any,
  parse: import_prop_types10.default.func,
  incrementIcon: import_prop_types10.default.node,
  decrementIcon: import_prop_types10.default.node,
  /** @ignore */
  tabIndex: import_prop_types10.default.any,
  name: import_prop_types10.default.string,
  placeholder: import_prop_types10.default.string,
  onKeyDown: import_prop_types10.default.func,
  onKeyPress: import_prop_types10.default.func,
  onKeyUp: import_prop_types10.default.func,
  autoFocus: import_prop_types10.default.bool,
  /**
   * @example ['disabled', ['1']]
   */
  disabled,
  /**
   * @example ['readOnly', ['1.5']]
   */
  readOnly: disabled,
  /** Adds a css class to the input container element. */
  containerClassName: import_prop_types10.default.string,
  inputProps: import_prop_types10.default.object,
  messages: import_prop_types10.default.shape({
    increment: import_prop_types10.default.string,
    decrement: import_prop_types10.default.string
  }),
  /** @ignore */
  localizer: import_prop_types10.default.object
};
var defaultProps3 = {
  incrementIcon: caretUp,
  decrementIcon: caretDown,
  min: -Infinity,
  max: Infinity,
  step: 1,
  precision: "auto"
};
function NumberPicker(uncontrolledProps) {
  const _useUncontrolled = useUncontrolled(uncontrolledProps, {
    value: "onChange"
  }), {
    className,
    containerClassName,
    disabled: disabled2,
    readOnly,
    value,
    min,
    max,
    incrementIcon,
    decrementIcon,
    placeholder,
    autoFocus,
    tabIndex,
    parse,
    name,
    onChange,
    messages,
    format,
    onKeyDown,
    onKeyPress,
    onKeyUp,
    inputProps,
    precision,
    step: pStep
  } = _useUncontrolled, elementProps = _objectWithoutPropertiesLoose20(_useUncontrolled, _excluded20);
  const localizer = useLocalizer(messages, {
    number: format
  });
  const ref = (0, import_react23.useRef)(null);
  const inputRef = (0, import_react23.useRef)(null);
  const repeaterRef = (0, import_react23.useRef)(null);
  const [focusEvents, focused] = useFocusManager(ref, uncontrolledProps, {
    willHandle(focused2) {
      if (focused2)
        focus();
    }
  });
  const handleMouseDown = useEventCallback((direction, event) => {
    if (event)
      event.persist();
    let method = direction === "UP" ? increment : decrement;
    let value2 = method(event), atTop = direction === "UP" && value2 === max, atBottom = direction === "DOWN" && value2 === min;
    if (atTop || atBottom)
      handleMouseUp();
    else if (!repeaterRef.current) {
      repeaterRef.current = createInterval(() => {
        handleMouseDown(direction, event);
      });
    }
  });
  const handleMouseUp = useEventCallback(() => {
    if (!repeaterRef.current)
      return;
    repeaterRef.current();
    repeaterRef.current = null;
  });
  const handleKeyDown = useEventCallback((event) => {
    if (readOnly)
      return;
    let key = event.key;
    notify(onKeyDown, [event]);
    if (event.defaultPrevented)
      return;
    if (key === "End" && isFinite(max))
      handleChange(max, event);
    else if (key === "Home" && isFinite(min))
      handleChange(min, event);
    else if (key === "ArrowDown") {
      event.preventDefault();
      decrement(event);
    } else if (key === "ArrowUp") {
      event.preventDefault();
      increment(event);
    }
  });
  const handleChange = (rawValue, originalEvent = null) => {
    let nextValue = clamp2(rawValue, min, max);
    if (value !== nextValue)
      notify(onChange, [nextValue, {
        rawValue,
        originalEvent,
        lastValue: value
      }]);
  };
  function focus() {
    var _inputRef$current;
    (_inputRef$current = inputRef.current) == null ? void 0 : _inputRef$current.focus();
  }
  function increment(event) {
    return step(pStep, event);
  }
  function decrement(event) {
    return step(-pStep, event);
  }
  function step(amount, event) {
    const nextValue = (value || 0) + amount;
    let p = precision === "auto" ? Math.max(getPrecision(value || 0), getPrecision(amount)) : precision;
    handleChange(p != null ? parseFloat(nextValue.toFixed(p)) : nextValue, event);
    return nextValue;
  }
  const clampedValue = clamp2(value, min, max);
  return import_react23.default.createElement(Widget_default, _extends21({}, elementProps, {
    focused,
    disabled: disabled2,
    readOnly,
    onKeyDown: handleKeyDown
  }, focusEvents, {
    ref,
    className: (0, import_classnames15.default)(className, "rw-number-picker")
  }), import_react23.default.createElement(WidgetPicker_default, {
    className: containerClassName
  }, import_react23.default.createElement(NumberInput_default, _extends21({}, inputProps, {
    role: "spinbutton",
    tabIndex,
    value: clampedValue,
    placeholder,
    autoFocus,
    editing: focused,
    localizer,
    parse,
    name,
    min,
    max,
    disabled: disabled2,
    readOnly,
    onChange: handleChange,
    onKeyPress,
    onKeyUp,
    innerRef: inputRef
  })), import_react23.default.createElement("span", {
    className: "rw-input-addon rw-number-picker-spinners"
  }, import_react23.default.createElement(Button_default, {
    icon: incrementIcon,
    className: "rw-picker-btn",
    disabled: clampedValue === max || disabled2 || readOnly,
    label: localizer.messages.increment({
      value: clampedValue,
      min,
      max
    }),
    onMouseUp: () => handleMouseUp(),
    onMouseDown: (e) => handleMouseDown("UP", e),
    onMouseLeave: () => handleMouseUp()
  }), import_react23.default.createElement(Button_default, {
    icon: decrementIcon,
    className: "rw-picker-btn",
    disabled: clampedValue === min || disabled2 || readOnly,
    label: localizer.messages.decrement({
      value: clampedValue,
      min,
      max
    }),
    onMouseUp: () => handleMouseUp(),
    onMouseDown: (e) => handleMouseDown("DOWN", e),
    onMouseLeave: () => handleMouseUp()
  }))));
}
NumberPicker.propTypes = propTypes8;
NumberPicker.defaultProps = defaultProps3;
var NumberPicker_default = NumberPicker;
function getPrecision(a) {
  if (!isFinite(a))
    return 0;
  let e = 1;
  let p = 0;
  while (Math.round(a * e) / e !== a) {
    e *= 10;
    p++;
  }
  return p;
}
export {
  Calendar_default as Calendar,
  Combobox_default as Combobox,
  DatePicker_default as DatePicker,
  DatePicker_default as DateTimePicker,
  DropdownList_default as DropdownList,
  Listbox_default as Listbox,
  Localization_default as Localization,
  Multiselect_default as Multiselect,
  NumberPicker_default as NumberPicker,
  SlideDownTransition_default as SlideDownTransition,
  SlideTransitionGroup_default as SlideTransitionGroup,
  TimeInput_default as TimeInput
};
//# sourceMappingURL=react-widgets.js.map
